#include <EUSCompat.h>

/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "rtable2.h"

bool_t
_DtCm_xdr_Buffer_2 (XDR *xdrs, Buffer_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Transaction_2 (XDR *xdrs, Transaction_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Period_2 (XDR *xdrs, Period_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Tag_2 (XDR *xdrs, Tag_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Attribute_2 (XDR *xdrs, Attribute_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Attribute_2), (xdrproc_t) _DtCm_xdr_Attribute_2))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->attr))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Attr_2 (XDR *xdrs, Attr_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (Attribute_2), (xdrproc_t) _DtCm_xdr_Attribute_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Except_2 (XDR *xdrs, Except_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->ordinal))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Except_2), (xdrproc_t) _DtCm_xdr_Except_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Exception_2 (XDR *xdrs, Exception_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (Except_2), (xdrproc_t) _DtCm_xdr_Except_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Id_2 (XDR *xdrs, Id_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_time_t (xdrs, &objp->tick))
		 return FALSE;
	 if (!xdr_long (xdrs, &objp->key))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Uid_2 (XDR *xdrs, Uid_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Id_2 (xdrs, &objp->appt_id))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Uid_2), (xdrproc_t) _DtCm_xdr_Uid_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Appt_2 (XDR *xdrs, Appt_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Id_2 (xdrs, &objp->appt_id))
		 return FALSE;
	 if (!_DtCm_xdr_Tag_2 (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->duration))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ntimes))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->what))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->mailto))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->script))
		 return FALSE;
	 if (!_DtCm_xdr_Period_2 (xdrs, &objp->period))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->author))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->client_data))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->exception, sizeof (Except_2), (xdrproc_t) _DtCm_xdr_Except_2))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->attr, sizeof (Attribute_2), (xdrproc_t) _DtCm_xdr_Attribute_2))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Appt_2), (xdrproc_t) _DtCm_xdr_Appt_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Abb_Appt_2 (XDR *xdrs, Abb_Appt_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Id_2 (xdrs, &objp->appt_id))
		 return FALSE;
	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->what))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->duration))
		 return FALSE;
	 if (!_DtCm_xdr_Period_2 (xdrs, &objp->period))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Abb_Appt_2), (xdrproc_t) _DtCm_xdr_Abb_Appt_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Apptid_2 (XDR *xdrs, Apptid_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->oid, sizeof (Id_2), (xdrproc_t) _DtCm_xdr_Id_2))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->new_appt, sizeof (Appt_2), (xdrproc_t) _DtCm_xdr_Appt_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Reminder_2 (XDR *xdrs, Reminder_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Id_2 (xdrs, &objp->appt_id))
		 return FALSE;
	 if (!xdr_time_t (xdrs, &objp->tick))
		 return FALSE;
	 if (!_DtCm_xdr_Attribute_2 (xdrs, &objp->attr))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Reminder_2), (xdrproc_t) _DtCm_xdr_Reminder_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Table_Res_Type_2 (XDR *xdrs, Table_Res_Type_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Table_Res_List_2 (XDR *xdrs, Table_Res_List_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Table_Res_Type_2 (xdrs, &objp->tag))
		 return FALSE;
	switch (objp->tag) {
	case AP_2:
		 if (!xdr_pointer (xdrs, (char **)&objp->Table_Res_List_2_u.a, sizeof (Appt_2), (xdrproc_t) _DtCm_xdr_Appt_2))
			 return FALSE;
		break;
	case RM_2:
		 if (!xdr_pointer (xdrs, (char **)&objp->Table_Res_List_2_u.r, sizeof (Reminder_2), (xdrproc_t) _DtCm_xdr_Reminder_2))
			 return FALSE;
		break;
	case AB_2:
		 if (!xdr_pointer (xdrs, (char **)&objp->Table_Res_List_2_u.b, sizeof (Abb_Appt_2), (xdrproc_t) _DtCm_xdr_Abb_Appt_2))
			 return FALSE;
		break;
	case ID_2:
		 if (!xdr_pointer (xdrs, (char **)&objp->Table_Res_List_2_u.i, sizeof (Uid_2), (xdrproc_t) _DtCm_xdr_Uid_2))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
_DtCm_xdr_Access_Status_2 (XDR *xdrs, Access_Status_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Table_Res_2 (XDR *xdrs, Table_Res_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Access_Status_2 (xdrs, &objp->status))
		 return FALSE;
	 if (!_DtCm_xdr_Table_Res_List_2 (xdrs, &objp->res))
		 return FALSE;
	return TRUE;
}
#define access_none_2 0x0 /* owner only */
#define access_read_2 0x1
#define access_write_2 0x2
#define access_delete_2 0x4
#define access_exec_2 0x8 /* execution permission is a hack! */
#define VOIDPID -1 /* pre-V3 tools do present pids */

bool_t
_DtCm_xdr_Access_Entry_2 (XDR *xdrs, Access_Entry_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->who))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->access_type))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Access_Entry_2), (xdrproc_t) _DtCm_xdr_Access_Entry_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Access_Args_2 (XDR *xdrs, Access_Args_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->target))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->access_list, sizeof (Access_Entry_2), (xdrproc_t) _DtCm_xdr_Access_Entry_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Range_2 (XDR *xdrs, Range_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_time_t (xdrs, &objp->key1))
		 return FALSE;
	 if (!xdr_time_t (xdrs, &objp->key2))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Range_2), (xdrproc_t) _DtCm_xdr_Range_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Table_Args_Type_2 (XDR *xdrs, Table_Args_Type_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Args_2 (XDR *xdrs, Args_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Table_Args_Type_2 (xdrs, &objp->tag))
		 return FALSE;
	switch (objp->tag) {
	case TICK_2:
		 if (!xdr_time_t (xdrs, &objp->Args_2_u.tick))
			 return FALSE;
		break;
	case APPTID_2:
		 if (!_DtCm_xdr_Apptid_2 (xdrs, &objp->Args_2_u.apptid))
			 return FALSE;
		break;
	case UID_2:
		 if (!xdr_pointer (xdrs, (char **)&objp->Args_2_u.key, sizeof (Uid_2), (xdrproc_t) _DtCm_xdr_Uid_2))
			 return FALSE;
		break;
	case APPT_2:
		 if (!xdr_pointer (xdrs, (char **)&objp->Args_2_u.appt, sizeof (Appt_2), (xdrproc_t) _DtCm_xdr_Appt_2))
			 return FALSE;
		break;
	case RANGE_2:
		 if (!xdr_pointer (xdrs, (char **)&objp->Args_2_u.range, sizeof (Range_2), (xdrproc_t) _DtCm_xdr_Range_2))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
_DtCm_xdr_Table_Args_2 (XDR *xdrs, Table_Args_2 *objp)
{
	register int32_t *buf;

	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->target))
		 return FALSE;
	 if (!_DtCm_xdr_Args_2 (xdrs, &objp->args))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Registration_2 (XDR *xdrs, Registration_2 *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->target))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->prognum))
				 return FALSE;
			 if (!xdr_u_long (xdrs, &objp->versnum))
				 return FALSE;
			 if (!xdr_u_long (xdrs, &objp->procnum))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->prognum);
		IXDR_PUT_U_LONG(buf, objp->versnum);
		IXDR_PUT_U_LONG(buf, objp->procnum);
		}
		 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Registration_2), (xdrproc_t) _DtCm_xdr_Registration_2))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->target))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_long (xdrs, &objp->prognum))
				 return FALSE;
			 if (!xdr_u_long (xdrs, &objp->versnum))
				 return FALSE;
			 if (!xdr_u_long (xdrs, &objp->procnum))
				 return FALSE;

		} else {
		objp->prognum = IXDR_GET_U_LONG(buf);
		objp->versnum = IXDR_GET_U_LONG(buf);
		objp->procnum = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Registration_2), (xdrproc_t) _DtCm_xdr_Registration_2))
			 return FALSE;
	 return TRUE;
	}

	 if (!_DtCm_xdr_Buffer_2 (xdrs, &objp->target))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->prognum))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->versnum))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->procnum))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (Registration_2), (xdrproc_t) _DtCm_xdr_Registration_2))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Table_Status_2 (XDR *xdrs, Table_Status_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
_DtCm_xdr_Registration_Status_2 (XDR *xdrs, Registration_Status_2 *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}
