$ $XConsortium: SUNW_TOOLTALK.msg /main/3 1996/07/24 19:00:34 drk $
$quote "
$set 1
3	"用于 %s 上的 rpc.ttdbserverd 的 clnt_create 失败 %s"
4	"出错：%s 上的 rpc.ttdbserverd 不在运行"
6	"服务器版本（%s）与数据库表的版本（%s）不相匹配。请运行（%s）版本\
的数据库服务器。"
7	"试图打开数据库表 %s：%s 失败"
14	"不能删除 X 根窗口特性 %s 通知这个会话过程"
15	"地址版本是 %d，但我只理解 %d!（地址：<%s>）"
17	"不能分析 X 显示名：“%s”"
18	"不能对文件 “%s” 的消息排队，这是由于内部出错 %d"
19	"不能删除过期的会话过程 <%s>（从文件“%s” 里的所关心的列表\
中），原因是内部出错 %d"
20	"不能删除无关的会话过程 <%s>（从文件“%s” 里的所关心的列表\
中），原因是内部出错 %d"
21	"tttracefile 语法错，位于行：\n%s"
22	"不能处理在 $%s 中的 tttracefile "
23	"若实际 UID 不等于有效 UID 则不允许跟踪"
24	"接收请求"
25	"空的文档和无文件"
26	"不能获得信息标识符; 由于 tt_message_arg_val()，操作可能是不可取消的"
27	"不能获得标题; 由于 tt_message_arg_val()，将没有标题"
28	"未知的操作数偏移"
$set 2
2	"发现进程类型 %s 的不可辨认的签名 -"
3	"没有面向连接的传输"
4	"一个 ToolTalk 客户在它收到它到期的信号前死亡了"
5	"到 ToolTalk 客户的连接在它收到要它检索消息的信号时丢失"
6	"发现另一个会话过程在运行（主机=%s，进程标识符=%d)"
7	"不能与宣称的会话过程联系（主机=%s，进程标识符=%d); 假定它崩溃了…"
8	"不能分析通知的会话过程标识符;用我自己的覆盖它…"
9	"%s 是版本 %d 类型的数据库， 而本版本只能读版本 %d 及更早的"
10	"不能从类型数据库 %s 中解码类型。它有可能被毁坏了。"
11	"覆盖 %s"
12	"忽略 ToolTalk 签名的未知属性 <%s>…"
13	"ttce2xdr 失败(状态=%d); 在类引擎“user”数据库中的类型没有被转换…"
14	"复制 ISAM 记录"
15	"ISAM 文件没有打开"
16	"非法的 ISAM 参数"
17	"非法的 ISAM 键描述符"
18	"打开太多的 ISAM 文件"
19	"错误的 ISAM 文件格式"
20	"ISAM 非互斥访问"
21	"ISAM 记录锁住了"
22	"ISAM 键已经存在"
23	"ISAM 键是主键"
24	"ISAM 文件结束或开始"
25	"没有发现 ISAM 记录"
26	"无当前 ISAM 记录"
27	"ISAM 文件 锁住了"
28	"ISAM 文件名太长"
29	"ISAM 不能分配存储器"
30	"ISAM RPC 时间到"
31	"断裂的 ISAM TCP/IP 连接"
32	"不能连接到 ISAM 服务器"
33	"不能输入 ISAM 数据"
34	"无局部 SAM 精灵"
35	"ISAM 内部致命出错"
36	"ISAM Locale/LANG（本地环境/语言）不匹配"
$set 3
2	"子（%d）退出，由于信号 %d%s"
3	"（内核卸出）"
4	"子（%d）既没有退出，也没有接收到信号！"
5	"因为 %m，不能最大化客户"
6	"没有可管理的范围。 使用 -c，-p，-d，或设置 $DISPLAY。"
7	"不能与 -c 一起使用 -S 选项"
8	"子 ttsession 以状态 %d 退出"
9	"子 ttsession 由于信号 %d%s 而退出"
10	"（内核卸出)"
11	"子 ttsession 既没有退出，也没有接收到信号！"
12	"启动"
13	"具有重读类型"
14	"类型出错; 保留旧的类型"
15	"$OPENWINHOME 没有设置"
16	"\n用法：ttsession [-a unix|des][-d 显示][-spStvhNX]"
17	"[-c 命令]\n\
 -c [命令]      开始一个进程树会话过程，并运行其中的命令。\n\
				此后的选项传给命令。 默认：$SHELL\n\
 -p             开始一个进程树会话过程，并打印它的标识符\n\
 -d 显示        在显示上开始一个 X 会话过程\n\
\n\
 -a unix|des    设置服务器的甄别等级\n\
 -s             沉默（silent）。不打印任何警告\n\
 -S             不生成后台进程\n\
 -N             最大化允许的客户数\n\
 -t             打开消息跟踪\n\
 -X             对静态类型使用 XDR 数据库（默认的)\n"
18	" -E		对静态类型使用类引擎\n"
19	"\n\
 -v             打印出版本号\n\
 -h             打印出此消息\n\
\n\
信号接口：\n\
 kill -USR1 ttsession_进程标识符    切换消息跟踪\n\
 kill -USR2 ttsession_进程标识符    重读静态类型"
20	"退出"

$set 4
2	"用法：\n\
tt_type_comp [-s] [-d 数据库] [-mM] 源文件\n\
tt_type_comp [-s] [-d 数据库] -r 类型 …\n\
-M          将源类型合并到指定的数据库中，不更新已有的类型\n\
-m          合并，但更新已有的类型。默认。\n\
-r          从指定数据库中删除源类型\n\
-d 数据库   要操作的数据库。用户、系统、或网络其中之一。 默认：用户\n\
tt_type_comp [-sE] -p|O|P [-d 数据库]\n\
tt_type_comp [-s]  -p|O|P 编译的文件\n\
-O               在标准输出上枚举所有读到的对象类型名字\n\
-P               在标准输出上枚举所有读到的进程类型名字\n\
-p               在标准输出上美观打印所有读到的 ToolTalk 类型\n\
-E               使用类引擎数据库而不是 XDR 数据库\n\
-d 数据库    要从中读的数据库。 用户、系统、或网络其中之一。 默认：所有的\n\
\n\
tt_type_comp [-s] -x [-o 编译的文件] 源文件\n\
-x      从源文件中编译类型(或标准输入，如果文件是 “-”)\n\
-o      将编译的类型写到“编译的文件”(或标准输出， 如果文件是 “-”)\n\
	默认：source_file.xdr，或“types.xdr”－如果源是标准输入的话\n\
\n\
tt_type_comp [-hv]\n\
-h      打印出此消息\n\
-s      不要打印出任何状态消息。\n\
\n\
这些 cpp 选项将会传递过去：\n\
	-undef -Dname -Idirectory -Uname -Ydirectory"
3	"类型文件中语义出错"
4	"不是一个合法的 ToolTalk 类型文件"
5	"不能从类引擎数据库中读取任何 ToolTalk 类型"
6	"不再支持合并类引擎表了"
7	"不能读取在 %s 数据库中的类型－版本不匹配"
8	"不能读取在 %s 数据库中的类型"
9	"$OPENWINHOME 没有设置"
10	"不能初始化用于写的 %s 数据库"
11	"不能删除对 %s 的旧的定义"
12	"正在覆盖"
13	"正在写"
14	"不能增加对 %s 的新的定义"
15	"不能删除对 %s 的旧的定义"
16	"正在覆盖"
17	"正在写"
18	"不能增加对 %s 的新的定义"
19	"在编译的类型中版本不匹配"
20	"不能读取数据库中的类型"
21	"$OPENWINHOME 没有设置"
22	"不能读取 %s 数据库中的类型－版本不匹配"
23	"不能读取 %s 数据库中的类型"
24	"$OPENWINHOME 没有设置"
25	"删除对象类型 %s\n"
26	"删除进程类型 %s\n"
27	"输出写到 %s\n"
28	"无效的数据库：%s"
29	"只能指定下列选项的其中之一：-O -P -m -M -p -r -x"
30	"预处理没有完成，因为：%s：%s"
31	"对象类型继承回路引用了 %s"
32	"祖先 %s （对象类型 %s 的）不存在"
33	"进程类型 %s 不存在，但是被对象类型 %s 称为实现者"
34	"在对象类型 %s 中定义了多重处理程序"
35	"在对象类型 %s 中的继承的签名在父亲中不存在"
36	"两个进程类型，%s 和 %s，具有同一个处理程序"
37	"祖先 %s （对象类型 %s 的）不存在"
38	"循环的对象类型继承体系结构 -\n  {"
39	"重复定义对象类型 %s "
40	"重复定义进程类型 %s"
$set 5
3	"安全性违犯：RPC 调用希望我来打开一个不是ToolTalk 数据库的文件"
4	"在用新的 rpc.ttdbserverd（>= 1.1）后，任何用旧的 rpc.ttdbserverd\
（<= 1.0.2）写的数据都将被忽略"
5	"在用新的 rpc.ttdbserverd（>= 1.1）后，任何用旧的 rpc.ttdbserverd\
（<= 1.0.2）写的数据都将被忽略"
6	"rpc.ttdbserverd 的版本（%s）与数据库表中\
的版本（%s）不匹配。请安装 %s 版本的 rpc.ttdbserverd（或更高版本)"
7	"用法：\nrpc.ttdbserverd [-S] [-n] [-m DTMOUNTPOINT]\nrpc.ttdbserverd [-S] [-v]"
8	"不能开始无用存储单元收集线程。thr_create()\n"
9	"不能为无用存储单元收集进行 fork()。\n"
$set 6
2	"用法：\nttdbck [-f 文件] [-k 对象关键字] [-t 类型] [-bx] \n\
[-impa] [-IZ] [-F 新文件名] [-T 新类型] [安装点]\n"
3	"ttdbck：如果指定了修复选项[-FTZ]，\n\
你就必须指定选择[-fkt]选项 \n或诊断选项[-bx] \n"
4	"编译的类型中版本不匹配"
5	"不能在数据库中读取类型"
6	"ttdbck：请试 'ttdbck -I'。\n"
7	"按文件名选择：%s\n"
8	"按对象标识符键选择："
9	"按类型选择：%s\n"
10	"诊断错误形成的实体\n"
11	"诊断对不存在的实体的引用\n"
12	"显示标识符\n"
13	"显示强制性的数据\n"
14	"显示特性和值数据\n"
15	"在检查前使用 NetISAM isrepair() 函数\n"
16	"通过设置类型 %s 修复\n"
17	"通过删除修复\n"
18	"排错打印输出级别 %d\n"
19	"通过设置到文件 %s 修复\n"
20	"出错：没有此规格的文件。\n"
21	"出错：没有此规格的类型。\n"
22	"出错：“%s” 不是一个安装的对象类型。\n"
23	"出错：规格对于类型特性具有多重值。\n"
24	"出错："
25	"ttdbck：没有发现错误。\n"
26	"出错："
$set 7
2	"用法：%s {ctx}[fhpPv[v]] [归档文件] 路径名 …\n\
	   %s {ctx}fL[hpPRv[v]] 归档文件 路径名 …\n\
       %s -v\n\
       %s -h\n"
3	"\tc       创建一个档案\n\
\tt       列表档案内容\n\
\tx       从档案中析出\n\
\tf       使用下一个参数 <归档文件名> 作为档案\n\
\th       遵循符号链接\n\
\tL       不引用 tar(1)\n\
\tp       保留文件模式\n\
\tP      （根）不保留对象的属主、修改时间，等等。\n\
\tR       不递归地进入目录\n\
\tv       冗长的\n\
\tvv      非常冗长的\n\
\t-v      打印版本号，然后退出\n\
\t-h[elp] 打印此消息\n"
4	"%s：不能从档案流中读取对象种类。\n"
5	"%s：不能从档案流中读取档案版本。\n"
6	"%s：发现档案版本版本%d，但期待版本 %d。\n"
7	"%s：在档案中发现未知种类 %d 的对象。\n"
8	"%s：不能从档案流中读取对象种类。\n"
9	"%s：不能从档案流中读取档案版本。\n"
10	"%s：发现档案版本版本%d，但期待版本 %d。\n"
11	"%s：在档案中发现未知种类 %d 的对象。\n"
$set 8
2	"%s：不能删除 %s 的ToolTalk 对象，因为 %s\n"
3	"%s：不能移动“%s”的 ToolTalk 对象到“%s”，因为 %s\n"
4	"%s：将不试图移动 ToolTalk 的对象：\n"
5	"用法：%s [-] [-fL] 路径1 路径2 \n\
	   %s [-] [-fL] 路径1 [路径2…] 目录\n\
	   %s -v\n\
	   %s -h\n"
6	"\t-L      不执行 mv(1)\n\
\t-v      打印版本号并退出\n\
\t-h      打印这个消息\n"
7	"%s：不能删除 %s 的 ToolTalk 对象，因为 %s\n"
8	"用法：%s [-] [-%s] %s …\n       %s -v\n       %s -h\n"
9	"文件"
10	"目录"
11	"\t-L      不执行 %s(1)\n\t-v      打印版本号并退出\n\t-h[elp] 打印这个消息\n"
12	"%s：不能删除 %s 的 ToolTalk 对象，因为 %s\n"
13	"用法：%s [-pL] 文件1 文件2\n\
	   %s [-prRL] 路径1 [路径2…] 目录\n\
	   %s -v\n\
	   %s -h\n"
14	"\t-L      不执行 cp(1)\n\
\t-v      打印版本号并退出\n\
\t-h      打印此消息\n"
$set 9
2	"用法：%s [-0FCa][-o 输出文件] [-S 会话过程 | 命令 [选项]]\n\
	   %s [-e 脚本 | -f 脚本文件][-S 会话过程 | 命令 [选项]]\n\
 -0             关闭会话过程中的消息跟踪，或运行命令\n\
				没有消息跟踪(即，只有 API 跟踪)\n\
 -F             跟随所有由‘命令’产生的或其后在‘会话过程’中由\n\
				ttsession(1) 启动的子进程\n\
 -C             不要跟踪 ToolTalk API 调用\n\
 -a             打印跟踪的消息的所有的属性，参数，和上下文槽。\n\
				默认是单行概要。\n\
 -e 脚本        从脚本中读取 tttracefile(4) 的设定\n\
 -f 脚本文件    从脚本文件从读取 tttracefile(4) 的设定。“-”：标准输入。\n\
 -o 输出文件    输出。 “-”：标准输出。默认：会话过程跟踪用标准输出，\n\
				命令跟踪用标准错误（tttrace 的）\n\
 -S 会话过程    要跟踪的会话过程。默认：参见 tt_default_session()\n\
 命令           要引用和跟踪的 ToolTalk 客户命令\n"
3	"%s：会话过程 <%s> 不支持 Session_Trace。  改用 kill -USR1 。参见 ttsession(1)。\n"
$set 10
2	"忽略传递给 Tts_address::add() 未知的 Tt_address\n"
3	"忽略传递给 Tts_address::remove() 未知的 Tt_address\n"
4	"忽略传递给 tts_address::tts_set() 未知的地址\n"
5	"忽略传递给 tts_address::tts_unset() 未知的地址\n"
6	"忽略由 tts_address::load() 所读取的未知的地址\n"
7	"Tts_arglist::Tts_arglist－读取实参出错－\n\t"
8	"Tts_arglist::load－遇到未知的实参类型－使用 BARG\n"
9	"调用了抽象类 Tts_arg::assign(Tt_pattern) －忽略之\n"
10	"调用了抽象类 Tts_arg::assign(Tt_message) －忽略之\n"
11	"调用了抽象类 Tts_arg::generate －忽略之\n"
12	"调用了抽象类 Tts_arg::save －忽略之\n"
13	"调用了抽象类 Tts_arg::load －忽略之\n"
14	"Tts_arg::mode_to_chars 无效的模式－使用 TT_INOUT\n"
15	"Tts_arg::chars_to_mode 无效的模式－使用 TT_INOUT\n"
16	"忽略传递给 Tts_category::set() 未知的 Tt_category \n"
17	"Tts_category::generate() 要求一个消息－忽略之\n"
18	"忽略由 ts_category::load() 读取的未知的分类（category）\n"
19	"忽略传递给 Tts_class::add() 未知的 Tt_class \n"
20	"忽略传递给 Tts_class::remove() 未知的 Tt_class \n"
21	"忽略传递给 tts_class::tts_set() 未知的类\n"
22	"忽略传递给 tts_class::tts_unset() 未知的类\n"
23	"忽略由 tts_class::load() 读取的未知的类\n"
24	"Tts_connection::universal_callback－没有用于模式的模具!\n"
25	"Tts_cntxtlist::Tts_cntxtlist－读取上下文出错－\n\t"
26	"Tts_contextlist::load－遇到未知的上下文类型－使用 BCNTXT\n"
27	"调用了抽象类 Tts_context::assign(Tt_pattern) －忽略之\n"
28	"调用了抽象类 Tts_context::assign(Tt_pattern) －忽略之\n"
29	"调用了抽象类 Tts_context::generate －忽略之\n"
30	"调用了抽象类 Tts_context::save －忽略之\n"
31	"调用了抽象类 Tts_context::load －忽略之\n"
32	"忽略传递给 Tts_disposition::add() 未知的 Tt_disposition\n"
33	"忽略传递给 Tts_disposition::remove() 未知的 Tt_disposition\n"
34	"忽略传递给 tts_disposition::tts_set() 未知的配置\n"
35	"忽略传递给 tts_disposition::tts_unset()未知的配置\n"
36	"忽略由 tts_disposition::load() 读取的未知的配置\n"
37	"调用 %s\n"
38	"ToolTalk 出错：%s\n        出处：源文件 %s，行 %d\n"
39	"警告：%s\n        出处：源文件 %s，行 %d\n"
40	" Tts_message_molding::send－试图发送未初始化的消息模具\n"
41	"忽略传递给 Tts_scope::add() 未知的 Tt_scope\n"
42	"忽略传递给 Tts_scope::remove() 未知的 Tt_scope\n"
43	"忽略传递给 tts_scope::tts_set() 未知的范围\n"
44	"忽略传递给 tts_scope::tts_unset() 未知的范围\n"
45	"忽略由 tts_scope::load() 读取的未知的范围\n"
46	"忽略传递给 Tts_state::add() 未知的 Tt_state\n"
47	"忽略传递给 Tts_state::remove() 未知的 Tt_state\n"
48	"忽略传递给 tts_state::tts_set() 未知的状态\n"
49	"忽略传递给 tts_state::tts_unset() 未知的状态\n"
50	"Tts_state::generate() 要求一个消息－忽略之\n"
51	"忽略由 tts_state::load() 读取的未知的状态\n"
82	"获取 TTSnoop 提示"
83	"－－－－－－－－-"
84	"对单独的按钮和设定的提示，可以在鼠标在感兴趣的按钮或"
85	"设置上时按下提示键。你的 HELPPATH 环境变量必需包括"
86	"TTSnoop 的 .info 文件的路径才能使之工作。要想看 ttsnoop "
87	"使用了哪些 API 调用，在引用 ttsnoop 时使用 -t 开关。"
88	""
89	"使用 TTSnoop"
90	"－－－－－－"
91	"要观察消息， 请选〈开始〉设定选择。"
92	""
93	"要关闭消息观察， 请选〈停止〉设定选择。"
94	""
95	"要限定消息的类型："
96	"      1) 选择〈模式〉按钮"
97	"      2) 输入你要观察的模式的类型"
98	"      3) 选择〈作用〉按钮"
99	""
100	"要高亮一条显示的信息："
101	"      1) 选择〈显示〉按钮"
102	"      2) 标记那些你要高亮的项"
103	"      3) 选择〈作用〉按钮"
104	""
105	"要发送一条消息："
106	"      1) 选择〈消息〉按钮"
107	"      2) 书写消息"
108	"      3) 选择〈发送消息〉按钮"
109	""
110	"要存储一条消息："
111	"      1) 选择〈消息〉按钮"
112	"      2) 书写消息"
113	"      3) 选择〈增加消息〉按钮"
114	""
115	"要发送一条存储的消息："
116	"      从〈发送消息〉菜单选择消息"
117	""
118	"要清除消息输出窗口，选择〈清除〉按钮。"
119	""
120	"一般性 ToolTalk 信息"
121	"－－－－－－－－－－"
122	"在通过 ToolTalk 接收或发送面向对象的"
123	"消息前，一个进程必需以消息分析器注册。"
124	"通过注册，该进程告诉 ToolTalk 几件事："
125	""
126	""
127	"      进程的进程类型（ptype)。这使得"
128	"      消息分析器将由此进程类型(ptype)"
129	"      实现的消息导向到此进程。"
130	""
131	""
132	"      此进程参加的会话过程。"
133	""
134	"      此进程观察的文档。传给此文档"
135	"      中的对象的消息可被路由至此进"
136	"      程。"
137	""
138	""
139	"注意，这些注册一般修改生成的模式。"
140	"有可能使用模式操纵 API 调用来观察"
141	"或处理面向对象的消息，但是此处描述"
142	"的方法要简短得多，因为它们利用了在"
143	"类型定义中声明的信息。"
144	""
145	"使用 tt_session_join 以成为会话过程的一部分。"
146	"参加时，你必需提供要参加的会话过程的会话过程"
147	"标识符。"
148	""
149	"当你的工具不再需要 ToolTalk 服务时，用"
150	"tt_session_quit 退出会话过程。"
151	""
152	"当你的工具装载一个文件，它必需通过调用"
153	"tt_file_join() 加入到此文件中的一组感"
154	"兴趣的进程中去；当此完成文件时，通过调"
155	"用 tt_file_quit() 退出进程组。某些工具"
156	"可以一次打开几个文件，而其它的工具只能"
157	"一次打开一个文件。"
158	"使用 TTSnoop"
159	"－－－－－－"
160	"要观察消息， 请选〈开始〉设定选择。"
161	""
162	"要关闭消息观察， 请选〈停止〉设定选择。"
163	""
164	"要限定消息的类型："
165	"      1) 选择〈模式〉按钮"
166	"      2) 输入你要观察的模式的类型"
167	"      3) 选择〈作用〉按钮"
168	""
169	"要高亮一条显示的信息："
170	"      1) 选择〈显示〉按钮"
171	"      2) 标记那些你要高亮的项"
172	"      3) 选择〈作用〉按钮"
173	""
174	"要发送一条消息："
175	"      1) 选择〈消息〉按钮"
176	"      2) 书写消息"
177	"      3) 选择〈发送消息〉按钮"
178	""
179	"要存储一条消息："
180	"      1) 选择〈消息〉按钮"
181	"      2) 书写消息"
182	"      3) 选择〈增加消息〉按钮"
183	""
184	"要发送一条存储的消息："
185	"      从〈发送消息〉菜单选择消息"
186	""
187	"要清除消息输出窗口，选择〈清除〉按钮。"
188	""
189	"一般性 ToolTalk 信息"
190	"－－－－－－－－－－"
191	"在通过 ToolTalk 接收或发送面向对象的"
192	"消息前，一个进程必需以消息分析器注册。"
193	"通过注册，该进程告诉 ToolTalk 几件事："
194	""
195	"      进程的进程类型（ptype)。这使得"
196	"      消息分析器将由此进程类型(ptype)"
197	"      实现的消息导向到此进程。"
198	""
199	"      此进程参加的会话过程。"
200	""
201	"      此进程观察的文档。传给此文档中"
202	"      的对象的消息可被路由至此进程。"
203	""
204	"注意，这些注册通常修改生成的模式。"
205	"有可能使用模式操纵 API 调用来观察"
206	"或处理面向对象的消息，但是此处描述"
207	"的方法要简短得多，因为它们利用了在"
208	"类型定义中声明的信息。"
209	""
210	"使用 tt_session_join 以成为会话过程的一部分。"
211	"加入时，你必需提供要参加的会话过程的会话过程"
212	"标识符。"
213	""
214	"当你的工具不再需要 ToolTalk 服务时，用"
215	"tt_session_quit 退出会话过程。"
216	""
217	"当你的工具装载一个文件时，它必需通过调"
218	"用 tt_file_join() 加入到此文件中的一组"
219	"有关的进程中去；当此完成文件时，通过调"
220	"用 tt_file_quit() 退出进程组。某些工具"
221	"可以一次打开几个文件，而其它的工具只能"
222	"一次打开一个文件。"
223	"开始/停止接收和显示消息。"
224	"清除消息窗口。"
225	"显示"
226	"－－"
227	"当一个消息到达你的进程，一文件描述符成为激活的。"
228	"取决于你的工具的特定结构，你可以当该文件描述符"
229	"成为激活时安排窗口系统工具包调用一个回调函数，"
230	"或是在 select(3) 调用中包括此文件描述符，该调用"
231	"阻塞若干文件描述符。不管哪一种情况，在文件描述符"
232	"成为激活后，你可调用 tt_message_receive() 获得"
233	"一个用于将要来到的消息的句柄。你可使用 tt_message_*()"
234	"检查消息的属性，以确定所要采取的行动。你可以识别"
235	"对你发送的消息的回信：通过比较句柄，通过用函数"
236	"调用 tt_message_user_set() 将对你的应用程序有意义"
237	"的信息放入消息中，或是通过用 tt_message_callback_add"
238	"和 tt_pattern_callback_add 函数调用将特定的回调"
239	"函数放入消息和模式中。"
240	""
241	"消息"
242	"－－"
243	"要发送一个消息，首先分配一个新的消息，填入适当的"
244	"信息，然后发送它。任何回信都将在同一消息中显现。"
245	"当用完该消息，释放用于此消息的存储。(对有返回值"
246	"要求的，释放是在任何需要的值复制出以后；对于通知，"
247	"释放是在发送之后马上进行)。"
248	""
249	"要分配一个新的消息，使用 tt_message_create()。它返回"
250	"指向此消息的“句柄”或“不透明指针”；要这个句柄在以"
251	"后的调用中引用此消息。"
252	""
253	"要填充消息的信息，使用 the tt_message_*_set() 调用;"
254	"对消息的每一个属性都有一个这样的函数。"
255	""
256	"你必须设置类、地址、操作和参数。"
257	""
258	"用 tt_message_send() 发送消息。"
259	"模式"
260	"－－"
261	"由于消息没有显式地被发送进程导向到特定的接收者，"
262	"“模式匹配”方法就被用来确定接收者。工具注册它们"
263	"所关心的消息的描述，而 ToolTalk 使用这些描述来"
264	"推导出消息的路由。保留一些独立的模式集合来描述"
265	"那些工具要处理的、以及要观察的消息。希望接收消"
266	"息的工具可以在运行时动态地或在安装时静态地声明"
267	"它们的兴趣。动态注册包含一个所有消息都要对之进"
268	"行比较的模式集合。如果一个消息与模式相匹配，注"
269	"册此模式的工具就有资格接收此消息。"
270	""
271	""
272	""
273	"在通过 ToolTalk 接收过程性消息前，进程必须注册"
274	"消息分析器。通过注册，该进程交给 ToolTalk 一些"
275	"模式；它以后将与这些模式匹配的消息分发给该进程。"
276	"模式可以两种方式创建："
277	""
278	"静态的。通过一进程类型(ptype)。进程可以向消息"
279	"分析器声明它的进程类型；ToolTalk 然后从进程类"
280	"型的每一特征中生成模式。这些生成的模式可以通过"
281	"加入和退出会话过程和文件而进行修改，就象在面向"
282	"对象的消息传递中的那样。"
283	"动态的。进程可以“凭空”创建模式，并向 ToolTalk"
284	"注册它们。此设施的一个典型的使用是消息登录设施，"
285	"它简单地观察所有路过的消息，在窗口中显示它们；"
286	"这样的设施在对消息协议的排错时相当有用。"
287	""
288	""
289	"此应用程序只使用动态模式。"
290	""
291	"要注册一个消息，必须首先分配一个新的消息，填入适当的"
292	"信息，然后注册它。当你用完此模式（只在你不再对与之"
293	"匹配的消息感兴趣以后），释放用于此模式的存储。"
294	""
295	""
296	"要分配一个新的模式，使用 tt_pattern_create()。它返回"
297	"指向此模式的“句柄”或“不透明指针”；用这个句柄在以"
298	"后的调用中引用此模式。"
299	""
300	"要填充模式的信息，使用 tt_pattern_*_add() 调用；"
301	"对模式的每一个属性都有一个这样的函数。有可能对模式"
302	"中的每一属性提供多个值；如果模式中的任一值匹配消息"
303	"中的值，则模式的属性与消息的属性相匹配。"
304	""
305	""
306	"此应用程序使用非互斥的设定以及逗号分隔的多个属性值。"
307	""
308	""
309	"要匹配消息而不考虑特定的属性值，只需简单地省略"
310	"模式的属性。"
311	""
312	"如果没有指定模式的属性，ToolTalk 服务就把消息"
313	"属性当成匹配的。你指定的模式属性越少，你适合"
314	"接收的消息就越多。"
315	""
316	"如果对模式属性指定了多个值，必须有一个值与消息"
317	"属性的值匹配。如果没有值匹配，ToolTalk 服务就"
318	"不把你的应用程序作为接收者考虑。"
319	""
320	"〈种类〉和〈范围〉属性总是必须提供的。"
321	""
322	"当模式是完全的， 用 tt_pattern_register() 函数"
323	"注册它，然后通过选择〈作用〉按钮加入到所需的"
324	"会话过程或文件中。"
325	""
326	"由于加入文件和会话过程的主要作用是及时更新"
327	"注册的模式，在加入后注册的模式将不会被更新。"
328	"你必须或者在加入前注册所有的模式，或者在注册"
329	"新的模式后重做一下加入。这也对由加入进程类型"
330	"所隐含注册的模式有效。当你在消息窗口中增加"
331	"消息，附于此按钮的菜单便会增长。你可以从中"
332	"选择消息发送它。"
333	"地址(Address)："
334	"由于有许多类型的工具，而不同的用户会在不同的"
335	"时间里使用不同的工具，通常不可能要消息的发信"
336	"者来精确地标明消息的接收者。而是，发信者给出"
337	"指定消息的含义的操作名，和可能给出该消息被导"
338	"向的对象，或该对象的类型（otype）。"
339	""
340	""
341	"对面向对象的消息使用对象或对象类型。如果地址"
342	"是处理程序，指定该处理程序。"
343	""
344	"        TT_PROCEDURE：提供了操作和参数。"
345	""
346	"        TT_OBJECT：   提供了对象，操作和参数。"
347	""
348	"        TT_HANDLER：  提供了处理程序，操作和参数。"
349	""
350	"        TT_OTYPE：    提供了对象类型，操作和参数。"
351	"处理程序(Handler)："
352	"如果你知道处理程序的确切的进程标识符（procid），你"
353	"可直接寻址此消息。这样做的一般方法是，进程先作一个"
354	"一般请求，然后从回信中获得“处理程序”属性，将以后"
355	"的消息导向同一个处理程序；这允许两个进程通过广播消"
356	"息取得会合，然后进行对话。"
357	""
358	"处理程序_进程类型(Handler_Ptype)："
359	"如果你知道要处理该消息的进程的进程类型，将它填入。"
360	"如果你查阅进程类型定义看看协议的细节，就会知道它的"
361	"进程类型(ptype)。"
362	"对象(Object)："
363	"填入该消息要送到的对象的对象标识符（objid）。"
364	"对象类型(otype)："
365	"该对象的类型。"
366	"操作(Op)："
367	"填入描述要进行的通知或请求的操作。查阅目标对象"
368	"的对象类型定义，以决定此操作名。"
369	""
370	"操作号(Opnum)："
371	"操作的编号。它用来区分重载的操作（操作具有相同的"
372	"名字但其参数类型不同），并简化客户的“内部”调度"
373	"（对给定消息引用适当的内部过程）。"
374	""
375	"范围(Scope)："
376	"使用会话过程范围，如果需要从与你的进程在同一会话过程中"
377	"的进程接收消息；使用文件范围，如果需要的是有关一文件的"
378	"消息。"
379	""
380	"      TT_SESSION：         从你的会话过程中的其它进程"
381	"                           里接收消息。"
382	""
383	"      TT_FILE：            接收有关加入的文件的消息。"
384	""
385	"      TT_BOTH：            接收有关文件和会话过程的"
386	"                           消息。"
387	""
388	"      TT_FILE_IN_SESSION： 接收加入的文件的、且在该"
389	"                           会话过程中的消息。"
390	"会话过程(Session)："
391	"对于会话过程范围，指定该会话过程（默认为 tt_default_session()）。"
392	""
393	"文件(File)："
394	"对于文件范围，指定该文件的名字。"
395	"种类(Category)："
396	"使用种类观察，如果你只想看看消息；使用种类的志愿者句柄"
397	"使之成为该消息唯一的处理程序。"
398	""
399	"    TT_OBSERVE：观察进程只得到有关它们自己信息的消息的"
400	"                拷贝。任意数量的进程可以观察信息。即使"
401	"                该消息是一请求，观察者也不向发信者返回"
402	"                值。通常，观察者所采取的行动只影响所用"
403	"                工具数据的交互式显示。"
404	""
405	""
406	"    TT_HANDLE： 实际执行基于此消息动作的处理进程。对任一"
407	"                给定消息只有一个进程处理它。如果该消息是"
408	"                请求，处理进程是那个返回任何值的进程。一"
409	"                般说来，处理程序所采取的行动会影响到该工"
410	"                具的数据的持久保留的表示。"
411	""
412	"类(Class)："
413	"对那些要返回值的消息，或那些你需要在它们被处理、或排队、"
414	"或在一进程开始处理该请求时有反馈信息给你的消息，使用类请"
415	"求。对那些只将事件通知其它进程的消息使用类通知。"
416	""
417	""
418	"    TT_NOTICE：  通知是告诉其它工具有事件发生了的那些消息。"
419	"                 发送通知的工具不期待回信。发信者只是让其它"
420	"                 工具知道发生了什么。"
421	"                 "
422	""
423	"     TT_REQUEST：请求是那些要求其它工具执行某一动作的消息。"
424	"                 通常，但不是永远，发送请求的工具期待某个返"
425	"                 回值。该值作为对请求的回信返回。即使没有值"
426	"                 返回，处理该请求的工具也发送一个指示成功或"
427	"                 失败的回信。"
428	""
429	"处置（Disposition）："
430	"指定在没有任一运行进程对此消息进行处理时要采取的行动。"
431	"如果该消息应排队，就排队直到一个 Handler_Ptype 的进程"
432	"注册。如果应该启动进程，就启动它。"
433	""
434	""
435	"    TT_QUEUE：排队该消息，直到一个具有合适进程类型的"
436	"              进程接收此消息。"
437	""
438	"    TT_START：试图启动一个没有运行但具有合适进程类型"
439	"              的进程。"
440	""
441	"注意 Tt_disposition 的值可以加在一起，所以 TT_QUEUE+"
442	"TT_START 意味同时排队该消息和试着启动一个进程。这在"
443	"启动失败（或被用户拒绝）后为保证该消息能很快在合适的"
444	"进程启动后被处理很有用。"
445	""
446	"状态(State)："
447	"消息的状态属性值。可能的值和它们的含义是："
448	""
449	""
450	"    TT_CREATED： 消息已经创建但还没有发送。在此状态下"
451	"                 只有消息的发信者可以看到该消息。"
452	""
453	"    TT_SENT：    消息已经发送但还没有被处理。"
454	""
455	"    TT_HANDLED： 消息已被处理，返回值有效。"
456	""
457	"    TT_FAILED：  消息不能交付给处理程序。"
458	""
459	"    TT_QUEUED：  消息已经排队以后交付。"
460	""
461	"    TT_STARTED： 试图启动一个处理此消息的进程。"
462	""
463	"    TT_REJECTED：消息已被一可能的处理程序拒绝。此状态"
464	"                 只被拒绝进程看见；ToolTalk 在将此消息"
465	"                 交付给另一个可能的处理程序前将此状态"
466	"                 变回 TT_SENT。"
467	"状态字(Status)："
468	"一个唯一的数字，表明由回信者返回的消息的结果。"
469	"此数字必须大于 TT_ERR_LAST（2047)。"
470	"状态字字符串(Status string)："
471	"一段描述此消息状态字的文本。"
472	"发信者(Sender)："
473	"标识发送此消息的进程。"
474	"发信者进程类型(Sender ptype)："
475	"发送此消息的进程的进程类型。"
476	"用户标识符(Uid)："
477	"发送此消息的进程的有效用户标识符。"
478	"组标识符(Gid)："
479	"发送此消息的进程的有效组标识符。"
480	"模式(Mode)："
481	"指定消息参数的模式。可能的值及其含义为："
482	""
483	""
484	"    TT_IN：   此参数由发信者所写，为处理程序及任何"
485	"              观察者所读。"
486	""
487	"    TT_OUT：  此参数由处理程序所写，为发信者以及任何"
488	"              回信观察者所读。"
489	""
490	"    TT_INOUT：此参数由发信者、处理程序以及任何观察者"
491	"              所读写。"
492	"类型(Type)："
493	"指明类型的字符串。虽然开发者可以创建他们自己的，普通"
494	"的值是“字符串”和“int”。"
495	"值(Value)："
496	"值的实际数据取决于类型。"
497	"当按下〈作用〉按钮时，对每一接收到的消息显示指定的"
498	"设定值。"
499	"按下按钮时，显示值将复位到最后作用的状态或其初始值，"
500	"哪个在后用哪个。"
501	"编辑接收上下文："
502	"增加，删除，或改变你要接收的上下文。"
503	"模式匹配"
504	"－－－－"
505	"由于消息没有显式地被发送进程导向到特定的接收者，"
506	"“模式匹配”方法就被用来确定接收者。工具注册它们"
507	"所关心的消息的描述，而 ToolTalk 使用这些描述来"
508	"推导出消息的路由。保留一些独立的模式集合来描述"
509	"那些工具要处理的、以及要观察的消息。希望接收消"
510	"息的工具可以在运行时动态地或在安装时静态地声明"
511	"它们的兴趣。动态注册包含一个所有消息都要对之进"
512	"行比较的模式集合。如果一个消息与模式相匹配，注"
513	"册此模式的工具就有资格接收此消息。"
514	""
515	""
516	""
517	"在通过 ToolTalk 接收过程性消息前，进程必须注册"
518	"消息分析器。通过注册，该进程交给 ToolTalk 一些"
519	"模式；它以后将与这些模式匹配的消息分发给该进程。"
520	"模式可以两种方式创建："
521	""
522	"静态的。通过一进程类型(ptype)。进程可以向消息"
523	"分析器声明它的进程类型；ToolTalk 然后从进程类"
524	"型的每一特征中生成模式。这些生成的模式可以通过"
525	"加入和退出会话过程和文件而进行修改，就象在面向"
526	"对象的消息传递中的那样。"
527	"动态的。进程可以“凭空”创建模式，并向 ToolTalk"
528	"注册它们。此设施的一个典型的使用是消息登录设施，"
529	"它简单地观察所有路过的消息，在窗口中显示它们；"
530	"这样的设施在对消息协议的排错时相当有用。"
531	""
532	""
533	"此应用程序只使用动态模式。"
534	""
535	"要注册一个消息，必须首先分配一个新的消息，填入适当的"
536	"信息，然后注册它。当你用完此模式（只在你不再对与之"
537	"匹配的消息感兴趣以后），释放用于此模式的存储。"
538	""
539	""
540	"要分配一个新的模式，使用 tt_pattern_create()。它返回"
541	"指向此模式的“句柄”或“不透明指针”；要这个句柄在以"
542	"后的调用中引用此模式。"
543	""
544	"要填充模式的信息，使用 tt_pattern_*_add() 调用；"
545	"对模式的每一个属性都有一个这样的函数。有可能对模式"
546	"中的每一属性提供多个值；如果模式中的任一值匹配消息"
547	"中的值，则模式的属性与消息的属性相匹配。"
548	""
549	""
550	"此应用程序使用非互斥的设定以及逗号分隔的多个属性值。"
551	""
552	""
553	"要匹配消息而不考虑特定的属性值，只需简单地省略"
554	"模式的属性。"
555	""
556	"如果没有指定模式的属性，ToolTalk 服务就把消息"
557	"属性当成匹配的。你指定的模式属性越少，你适合"
558	"接收的消息就越多。"
559	""
560	"如果对模式属性指定了多个值，必须有一个值与消息"
561	"属性的值匹配。如果没有值匹配，ToolTalk 服务就"
562	"不把你的应用程序作为接收者考虑。"
563	""
564	"〈种类〉和〈范围〉属性总是必须提供的。"
565	""
566	"当模式是完全的，用 tt_pattern_register() 函数"
567	"注册它，然后通过选择〈作用〉按钮加入到所需的"
568	"会话过程或文件中。"
569	""
570	"由于加入文件和会话过程的主要作用是及时更新"
571	"注册的模式，在加入后注册的模式将不会被更新。"
572	"你必须或者在加入前注册所有的模式，或者在注册"
573	"新的模式后重做一下加入。这也对由加入进程类型"
574	"所隐含注册的模式有效。当你在消息窗口中增加"
575	"消息，附于此按钮的菜单便会增长。你可以从中"
576	"选择消息发送它。"
577	"地址(Address)："
578	"由于有许多类型的工具，而不同的用户会在不同的"
579	"时间里使用不同的工具，通常不可能要消息的发信"
580	"者来精确地标明消息的接收者。而是，发信者给出"
581	"指定消息的含义的操作名，和可能给出该消息被导"
582	"向的对象，或该对象的类型（otype）。"
583	""
584	""
585	"对面向对象的消息使用对象或对象类型。如果地址"
586	"是处理程序，指定该处理程序。"
587	""
588	"        TT_PROCEDURE：提供了操作和参数。"
589	""
590	"        TT_OBJECT：   提供了对象，操作和参数。"
591	""
592	"        TT_HANDLER：  提供了处理程序，操作和参数。"
593	""
594	"        TT_OTYPE：    提供了对象类型，操作和参数。"
595	"对象(Object)："
596	"填入该消息要送到的对象的对象标识符（objid）。"
597	"对象类型(OType)："
598	"该对象的类型。"
599	"操作(Op)："
600	"填入描述要进行的通知或请求的操作。查阅目标对象"
601	"的对象类型定义，以决定此操作名。"
602	"范围(Scope)："
603	"使用会话过程范围，如果需要从与你的进程在同一会话过程中"
604	"的进程接收消息；使用文件范围，如果需要的是有关一文件的"
605	"消息。"
606	""
607	"      TT_SESSION：          从你的会话过程中的其它进程"
608	"                            里接收消息。"
609	""
610	"      TT_FILE：             接收有关加入的文件的消息。"
611	""
612	"      TT_BOTH：             接收有关文件和会话过程的"
613	"                            消息。"
614	""
615	"      TT_FILE_IN_SESSION：  接收加入的文件的、且在该"
616	"                            会话过程中的消息。"
617	"文件(File)："
618	"对于文件范围，指定该文件的名字。"
619	"会话过程(Session)："
620	"对于会话过程范围，指定该会话过程（默认为 tt_default_session()）。"
621	""
622	"种类(Category)："
623	"使用种类观察，如果你只想看看消息；使用种类的志愿者句柄"
624	"使之成为该消息唯一的处理程序。"
625	""
626	"    TT_OBSERVE：观察进程只得到有关它们自己信息的消息的"
627	"                拷贝。任意数量的进程可以观察信息。即使"
628	"                该消息是一请求，观察者也不向发信者返回"
629	"                值。通常，观察者所采取的行动只影响所用"
630	"                工具数据的交互式显示。"
631	""
632	""
633	"    TT_HANDLE： 实际执行基于此消息动作的处理进程。对任一"
634	"                给定消息只有一个进程处理它。如果该消息是"
635	"                请求，处理进程是那个返回任何值的进程。一"
636	"                般说来，处理程序所采取的行动会影响到该工"
637	"                具的数据的持久保留的表示。"
638	""
639	"类(Class)："
640	"对那些要返回值的消息，或那些你需要在它们被处理、或排队、"
641	"或在一进程开始处理该请求时有反馈信息给你的消息，使用类请"
642	"求。对那些只将事件通知其它进程的消息使用类通知。"
643	""
644	""
645	"    TT_NOTICE：  通知是告诉其它工具有事件发生了的那些消息。"
646	"                 发送通知的工具不期待回信。发信者只是让其它"
647	"                 工具知道发生了什么。"
648	"                 "
649	""
650	"     TT_REQUEST：请求是那些要求其它工具执行某一动作的消息。"
651	"                 通常，但不是永远，发送请求的工具期待某个返"
652	"                 回值。该值作为对请求的回信返回。即使没有值"
653	"                 返回，处理该请求的工具也发送一个指示成功或"
654	"                 失败的回信。"
655	""
656	"状态(State)："
657	"消息的状态属性值。可能的值和它们的意义是："
658	""
659	""
660	"    TT_CREATED： 消息已经创建但还没有发送。在此状态下"
661	"                 只有消息的发信者可以看到该消息。"
662	""
663	"    TT_SENT：    消息已经发送但还没有被处理。"
664	""
665	"    TT_HANDLED： 消息已被处理，返回值有效。"
666	""
667	"    TT_FAILED：  消息不能交付给处理程序。"
668	""
669	"    TT_QUEUED：  消息已经排队以后交付。"
670	""
671	"    TT_STARTED： 试图启动一个处理此消息的进程。"
672	""
673	"    TT_REJECTED：消息已被一可能的处理程序拒绝。此状态"
674	"                 只被拒绝进程看见；ToolTalk 在将此消息"
675	"                 交付给另一个可能的处理程序前将此状态"
676	"                 变回 TT_SENT。"
677	"处置（Disposition）："
678	"指定在没有任一运行进程对此消息进行处理时要采取的行动。"
679	"如果该消息应排队，就排队直到一个 Handler_Ptype 的进程"
680	"注册。如果应该启动进程，就启动它。"
681	""
682	""
683	"    TT_QUEUE：排队该消息，直到一个具有合适进程类型的"
684	"              进程接收此消息。"
685	""
686	"    TT_START：试图启动一个没有运行但具有合适进程类型"
687	"              的进程。"
688	""
689	"注意 Tt_disposition 的值可以加在一起，所以 TT_QUEUE+"
690	"TT_START 意味同时排队该消息和试着启动一个进程。这在"
691	"启动失败（或被用户拒绝）后为保证该消息能很快在合适的"
692	"进程启动后被处理很有用。"
693	""
694	"发信者(Sender)："
695	"标识发送此消息的进程。"
696	"发信者进程类型(Sender ptype)："
697	"发送此消息的进程的进程类型。"
698	"参数(Args)："
699	"填入特定于该操作的任何参数。以后用 tt_message_arg_add"
700	"增加每一参数。对每一参数，你必须指定：模式（输入，输"
701	"出，输入输出）、类型、以及若模式为输入或输入输出时值。"
702	"模式(Mode)："
703	"指定消息参数的模式。可能的值及其含义为："
704	""
705	""
706	"    TT_IN：   此参数由发信者所写，为处理程序及任何"
707	"              观察者所读。"
708	""
709	"    TT_OUT：  此参数由处理程序所写，为发信者以及任何"
710	"              回信观察者所读。"
711	""
712	"    TT_INOUT：此参数由发信者、处理程序以及任何观察者"
713	"              所读写。"
714	"类型(Type)："
715	"指明类型的字符串。虽然开发者可以创建他们自己的，普通"
716	"的值是“字符串”和“int”。"
717	"值(Value)："
718	"值的实际数据取决于类型。"
719	"增加按钮(Add Button)："
720	"用模式、类型和值增加一个参数。"
721	"删除按钮(Delete Button)："
722	"删除选择的参数。"
723	"更改按钮(Change Button)："
724	"将选择的参数更改成模式、类型和值当前的值。"
725	""
726	"作用按钮(Apply button)："
727	"注册接收与此模式匹配的消息。"
728	"名字(Name)："
729	"此上下文的名字。"
730	"值(Value)："
731	"适合于此类型的值，"
732	""
733	"即：55 对应于整数类型，“fred”对应于字符类型，或"
734	" ^V^L^X 对应于字节类型。"
735	"增加上下文："
736	"将名字和值字段的当前值增加到上下文表中去。"
737	""
738	"删除上下文："
739	"从上下文表中删除所选择的项。"
740	"更改上下文："
741	"将选择的项更改到名字和值字段中的内容。"
742	"编辑发送上下文："
743	"弹出窗口编辑你希望发送的上下文表。"
744	"消息"
745	"－－"
746	"要发送一个消息，首先分配一个新的消息，填入适当的"
747	"信息，然后发送它。任何回信都将在同一消息中显现。"
748	"当用完该消息，释放用于此消息的存储。（对有返回值"
749	"要求的，释放是在任何需要的值复制出以后；对于通知，"
750	"释放是在发送之后马上进行）。"
751	""
752	"要分配一个新的消息，使用 tt_message_create()。它返回"
753	"指向此消息的“句柄”或“不透明指针”；用这个句柄在以"
754	"后的调用中引用此消息。"
755	""
756	"要填充消息的信息，使用 the tt_message_*_set() 调用;"
757	"对消息的每一个属性都有一个这样的函数。"
758	""
759	"你必须设置类、地址、操作和参数。"
760	""
761	"用 tt_message_send() 发送消息。"
762	"地址(Address)："
763	"由于有许多类型的工具，而不同的用户会在不同的"
764	"时间里使用不同的工具，通常不可能要消息的发信"
765	"者来精确地标明消息的接收者。而是，发信者给出"
766	"指定消息的含义的操作名，和可能给出该消息被导"
767	"向的对象，或该对象的类型（otype）。"
768	""
769	""
770	"对面向对象的消息使用对象或对象类型。如果地址"
771	"是处理程序，指定该处理程序。"
772	""
773	"        TT_PROCEDURE：提供了操作和参数。"
774	""
775	"        TT_OBJECT：   提供了对象，操作和参数。"
776	""
777	"        TT_HANDLER：  提供了处理程序，操作和参数。"
778	""
779	"        TT_OTYPE：    提供了对象类型，操作和参数。"
780	"处理程序(Handler)："
781	"如果你知道处理程序的确切的进程标识符（procid），你"
782	"直接寻址此消息。这样做的一般方法是，一进程先作一个"
783	"一般请求，然后从回信中获得“处理程序”属性，将以后"
784	"的消息导向同一个处理程序；这允许两个进程通过广播消"
785	"息取得会合，然后进行对话。"
786	""
787	"处理程序_进程类型(Handler_Ptype)："
788	"如果你知道要处理该消息的进程的进程类型，将它填入。"
789	"如果你查阅进程类型定义看看协议的细节，就会知道它的"
790	"进程类型(ptype)。"
791	"对象(Object)："
792	"填入该消息要送到的对象的对象标识符（objid）。"
793	"对象类型(otype)："
794	"该对象的类型。"
795	"操作(Op)："
796	"填入描述要进行的通知或请求的操作。查阅目标对象"
797	"的对象类型定义，以决定此操作名。"
798	""
799	"范围(Scope)："
800	"使用会话过程范围，如果需要从与你的进程在同一会话过程中"
801	"的进程接收消息；使用文件范围，如果需要的是有关一文件的"
802	"消息。"
803	""
804	"      TT_SESSION：         从你的会话过程中的其它进程"
805	"                           里接收消息。"
806	""
807	"      TT_FILE：            接收有关加入的文件的消息。"
808	""
809	"      TT_BOTH：            接收有关文件和会话过程的消息。"
810	""
811	"      TT_FILE_IN_SESSION： 接收加入的文件的、且在该"
812	"                           会话过程中的消息。"
813	"会话过程(Session)："
814	"对于会话过程范围，指定该会话过程（默认为 tt_default_session()）。"
815	""
816	"文件(File)："
817	"对于文件范围，指定该文件的名字。"
818	"类(Class)："
819	"对那些要返回值的消息，或那些你需要在它们被处理、或排队、"
820	"或在一进程开始处理该请求时有反馈信息给你的消息，使用类请"
821	"求。对那些只将事件通知其它进程的消息使用类通知。"
822	""
823	""
824	"    TT_NOTICE：  通知是告诉其它工具有事件发生了的那些消息。"
825	"                 发送通知的工具不期待回信。发信者只是让其它"
826	"                 工具知道发生了什么。"
827	"                 "
828	""
829	"     TT_REQUEST：请求是那些要求其它工具执行某一动作的消息。"
830	"                 通常，但不是永远，发送请求的工具期待某个返"
831	"                 回值。该值作为对请求的回信返回。即使没有值"
832	"                 返回，处理该请求的工具也发送一个指示成功或"
833	"                 失败的回信。"
834	""
835	"处置（Disposition）："
836	"指定在没有任一运行进程对此消息进行处理时要采取的行动。"
837	"如果该消息应排队，就排队直到一个 Handler_Ptype 的进程"
838	"注册。如果应该启动进程，就启动它。"
839	""
840	""
841	"    TT_QUEUE：排队该消息，直到一个具有合适进程类型的"
842	"              进程接收此消息。"
843	""
844	"    TT_START：试图启动一个没有运行但具有合适进程类型"
845	"              的进程。"
846	""
847	"注意 Tt_disposition 的值可以加在一起，所以 TT_QUEUE+"
848	"TT_START 意味同时排队该消息和试着启动一个进程。这在"
849	"启动失败（或被用户拒绝）后为保证该消息能很快在合适的"
850	"进程启动后被处理很有用。"
851	""
852	"发信者进程类型(Sender_Ptype)："
853	"发送此消息的进程的进程类型。"
854	"状态字(Status)："
855	"一个唯一的数字，表明由回信者返回的消息的结果。"
856	"此数字必须大于 TT_ERR_LAST（2047)。"
857	"状态字字符串(Status string)："
858	"一段描述此消息状态字的文本。"
859	"参数(Args)："
860	"填入特定于该操作的任何参数。以后用 tt_message_arg_add"
861	"增加每一参数。对每一参数，你必须指定：模式（输入，输"
862	"出，输入输出），类型，以及若模式为输入或输入输出时值。"
863	""
864	"模式(Mode)："
865	"指定消息参数的模式。可能的值及其含义为："
866	""
867	""
868	"    TT_IN：   此参数由发信者所写，为处理程序及任何"
869	"              观察者所读。"
870	""
871	"    TT_OUT：  此参数由处理程序所写，为发信者以及任何"
872	"              回信观察者所读。"
873	""
874	"    TT_INOUT：此参数由发信者、处理程序以及任何观察者"
875	"              所读写。"
876	"类型(Type)："
877	"指明类型的字符串。虽然开发者可以创建他们自己的，普通"
878	"的值是“字符串” 和 “int”。"
879	"值(Value)："
880	"值的实际数据取决于类型。"
881	"增加按钮(Add Button)："
882	"用模式、类型和值增加一个参数。"
883	"删除按钮(Delete Button)："
884	"删除选择的参数。"
885	"更改按钮(Change Button)："
886	"将选择的参数更改成模式、类型和值当前的值。"
887	""
888	"发送按钮(Send button)："
889	"发送此消息。也在标准输出上打印出用于创建和发送"
890	"此消息的 ToolTalk 调用。"
891	"名字(Name)："
892	"此上下文的名字。"
893	"值(Value)："
894	"此上下文的值，解释为类型。"
895	"增加："
896	"在文本字段中增加此值作为新的上下文。"
897	"删除："
898	"删除当前选择的上下文。"
899	"更改："
900	"更改选择的上下文以反应文本字段中的当前内容。"
901	""
902	"不能打开管道用于筛选输出。\n"
903	"Tts_string_list:generate 要求消息 －忽略\n"
$set 11
2	"TT_OK\t请求成功。"
3	"TT_WRN_NOTFOUND\t因为没有找到该对象，所以它没有被删除。"
4	"TT_WRN_STALE_OBJID\tT在此消息中的对象属性被一更新的属性替换了。更新获得此对象标识符的地方。"
5	"TT_WRN_STOPPED\t此查询被过滤器过程终止了。"
6	"TT_WRN_SAME_OBJID\t此移动的对象仍保留同样的对象标识符。"
7	"TT_WRN_START_MESSAGE\t此消息引起这个过程的启动。即使它是个通知，对此消息也必须回信。"
8	"TT_WRN_APPFIRST\t此代码应不被使用。"
9	"TT_WRN_LAST\t此代码应不被使用。"
10	"TT_ERR_CLASS\t传递的 Tt_class 值是无效的。"
11	"TT_ERR_DBAVAIL\t无法获得所需要的数据库。 此情况可能是暂时的，稍后再试可能会成功。"
12	"TT_ERR_DBEXIST\t所需要的数据库不存在。 必须在此动作进行前创建此数据库。"
13	"TT_ERR_FILE\t无法找到文件对象。"
14	"TT_ERR_MODE\tTt_mode 的值是无效的。"
15	"TT_ERR_ACCESS\t试图以系统禁止的方式访问一个 ToolTalk 对象。"
16	"TT_ERR_NOMP\t没有 ttsession 进程运行着，可能是由于 tt_open() 还没有被调用。 如果该代码从 tt_open() 中返回，这意味着 ttsession 不能被启动，一般代表 ToolTalk 没有安装在此系统中。"
17	"TT_ERR_NOTHANDLER\t只有消息的处理程序可以做此事。"
18	"TT_ERR_NUM\t传递的整数值是无效的。"
19	"TT_ERR_OBJID\t传递的对象标识符没有引用任何已有的对象规格。"
20	"TT_ERR_OP\t传递的操作名在语法上非法。"
21	"TT_ERR_OTYPE\t传递的对象类型不是一个已安装的对象类型名。"
22	"TT_ERR_ADDRESS\t传递的 Tt_address 值是非法的。"
23	"TT_ERR_PATH\t传递的文件路径中的一个目录不存在或不能读。"
24	"TT_ERR_POINTER\t传递的不透明指针（句柄）没有指向一个合适类型的对象。"
25	"TT_ERR_PROCID\t传递的进程标识符无效。"
26	"TT_ERR_PROPLEN\t传递的特性值太长。"
27	"TT_ERR_PROPNAME\t传递的特性名在语法上非法。"
28	"TT_ERR_PTYPE\t传递的进程类型不是一个已安装的进程类型。"
29	"TT_ERR_DISPOSITION\t传递的 Tt_disposition 值是无效的。"
30	"TT_ERR_SCOPE\t传递的 Tt_scope 值是无效的。"
31	"TT_ERR_SESSION\t传递的会话过程标识符不是一个激活的会话过程名。"
32	"TT_ERR_VTYPE\t传递的值类型名无效。"
33	"TT_ERR_NO_VALUE\t不存在具有给定的名字和数值的特性值。"
34	"TT_ERR_INTERNAL\t内部出错（故障）"
35	"TT_ERR_READONLY\t此属性不能被更改。"
36	"TT_ERR_NO_MATCH\t无法找到此消息的处理程序，该处置还没排队或启动。"
37	"TT_ERR_UNIMP\t函数没实现。"
38	"TT_ERR_OVERFLOW\t太多的激活消息（稍后再试）。"
39	"TT_ERR_PTYPE_START\t运行进程类型的实例的企图失败。"
40	"TT_ERR_CATEGORY\t模式对象没有设定分类。"
41	"TT_ERR_DBUPDATE\t此数据库不一致：另一个 tt_spec_write 首先更新了对象。"
42	"TT_ERR_DBFULL\tTooltalk 数据库满了。"
43	"TT_ERR_DBCONSIST\t数据库被毁坏，或访问信息不完全（运行 ttdbck）。"
44	"TT_ERR_STATE\t对要执行的操作，Tt_state 中的 Tt_message 是无效的。"
45	"TT_ERR_NOMEM\t存储器不够。"
46	"TT_ERR_SLOTNAME\t槽名在语法上非法。"
47	"TT_ERR_XDR\t传递的 XDR 进程求值为零长度，或在调用中失败。"
48	"TT_ERR_NETFILE\t网络文件名在语法上非法。"
49	"TT_DESKTOP_UNMODIFIED\t操作没有作用到不可修改的实体上。"
50	"TT_MEDIA_ERR_SIZE\t指定的大小太大或太小"
51	"TT_MEDIA_ERR_FORMAT\t此数据与它们宣称的格式不一致。"
52	"TT_ERR_APPFIRST\t此代码应不被使用。"
53	"TT_ERR_LAST\t此代码应不被使用。"
54	"TT_STATUS_LAST\t此代码应不被使用。"
55	"未知的 Tt_status 值。"
56	"TT_DESKTOP_EPERM\t不是超级用户"
57	"TT_DESKTOP_ENOENT\t没有此文件或者目录"
58	"TT_DESKTOP_EINTR\t中断的系统调用"
59	"TT_DESKTOP_EIO\tI/O 出错"
60	"TT_DESKTOP_EAGAIN\t没有更多的进程"
61	"TT_DESKTOP_ENOMEM\t空间不够"
62	"TT_DESKTOP_EACCES\t权限否决"
63	"TT_DESKTOP_EFAULT\t错误的地址"
64	"TT_DESKTOP_EEXIST\t文件已经存在"
65	"TT_DESKTOP_ENODEV\t无此设备"
66	"TT_DESKTOP_ENOTDIR\t不是一个目录"
67	"TT_DESKTOP_EISDIR\t是一个目录"
68	"TT_DESKTOP_EINVAL\t非法实参"
69	"TT_DESKTOP_ENFILE\t文件表溢出"
70	"TT_DESKTOP_EMFILE\t太多的打开文件"
71	"TT_DESKTOP_ETXTBSY\t文件文件忙"
72	"TT_DESKTOP_EFBIG\t文件太大"
73	"TT_DESKTOP_ENOSPC\t设备上没有空间留下"
74	"TT_DESKTOP_EROFS\t只读文件系统"
75	"TT_DESKTOP_EMLINK\t太多的链接"
76	"TT_DESKTOP_EPIPE\t管道破裂"
77	"TT_DESKTOP_ENOMSG\t没有需要的类型的消息"
78	"TT_DESKTOP_EDEADLK\t死锁条件"
79	"TT_DESKTOP_ENODATA\t没有可用的数据"
80	"TT_DESKTOP_EPROTO\t协议出错"
81	"TT_DESKTOP_ENOTEMPTY\t目录不空"
82	"TT_DESKTOP_ETIMEDOUT\t连接时间到"
83	"TT_DESKTOP_EALREADY\t操作已经在进行中"
84	"TT_DESKTOP_ECANCELED\t操作取消了"
85	"TT_DESKTOP_ENOTSUP\t不支持"
