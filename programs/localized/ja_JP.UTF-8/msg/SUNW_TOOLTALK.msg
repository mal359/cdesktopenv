$ $TOG: SUNW_TOOLTALK.msg /main/7 1999/09/16 13:45:00 mgreess $
$quote "
$set 1
3	"%s 上の rpc.ttdbserverd に対する clnt_create が失敗しました。%s"
4	"エラー: %s 上の rpc.ttdbserverd は動作していません。"
6	"サーバ・バージョン(%s)がデータベース・テーブルのバージョン(%s)と一致しません。\
バージョン %s のデータベース・サーバを動作させてください。"
7	"データベース・テーブル %s:%s を開こうとしましたが失敗しました。"
14	"このセッションを決定したＸルート・ウィンドウ属性 %s を\
削除できません。"
15	"アドレス・バージョンが %d ですが、\
%d しか理解できません。(アドレス: <%s>)"
17	"Ｘディスプレイ名 \"%s\" を構文解析できません。"
18	"ファイル \"%s\" のメッセージをキューに入れられません。内部エラー %d のためです。"
19	"古くなったセッション <%s> をファイル \"%s\" の配信対象の一覧から\
削除できません。内部エラー %d のためです。"
20	"配信対象でないセッション <%s> をファイル \"%s\" の配信対象の\
一覧から削除できません。内部エラー %d のためです。"
21	"%s 行に tttracefile 構文エラーがあります。"
22	"$%s 内で tttracefile を処理できません。"
23	"実際のユーザ ID が有効なユーザ ID でない場合には、トレースできません。"
24	"要求を受け入れています。"
25	"ドキュメントは空でファイルはありません。"
26	"messageID を取得できません。\
tt_message_arg_val() が原因で、操作を取り消せない可能性があります。"
27	"タイトルを取得できません。\
tt_message_arg_val() が原因で、ドキュメントはタイトルなしになります。"
28	"未知の opnum オフセット"
$set 2
2	"区別できないシグニチャが ptype %s に見つかりました。"
3	"接続型トランスポートはありません。"
4	"ToolTalk クライアントが、メッセージを検索するために必要な\
シグナルを発信する前に終了しました。"
5	"メッセージを検索するためのシグナル発信中に、\
ToolTalk クライアントへの接続が切れました。"
6	"他のセッションが動作中です。(ホスト=%s, pid=%d)"
7	"セッションと接続できません。(ホスト=%s, pid=%d)\
クラッシュしたようです..."
8	"示されたセッション ID を構文解析できません。\
システム独自のセッション ID で上書きします..."
9	"%s はバージョン %d タイプのデータベースであり、\
このバージョンはバージョン %d 以前のみを読み取ることができます。"
10	"types データベース %s の types を解読できません。\
壊れている可能性があります。"
11	"%s を上書きしました。"
12	"ToolTalk シグニチャの未知の属性 <%s> を無視します..."
13	"ttce2xdr が失敗しました。(ステータス =%d) \
分類機構 \"user\" データベースの types を変換できません..."
14	"ISAM レコードが重複しています。"
15	"ISAM ファイルを開けません。"
16	"不正な ISAM 引き数です。"
17	"不正な ISAM キー記述子です。"
18	"開いている ISAM ファイルが多すぎます。"
19	"ISAM ファイル形式が不正です。"
20	"ISAM 非排他的アクセスです。"
21	"ISAM レコードはロックされています。"
22	"ISAM キーはすでに存在します。"
23	"ISAM キーは主キーです。"
24	"ISAM ファイルの終了または開始。"
25	"ISAM レコードが見つかりません。"
26	"現在 ISAM レコードはありません。"
27	"ISAM ファイルはロックされています。"
28	"ISAM ファイル名が長すぎます。"
29	"ISAM はメモリを割り当てられません。"
30	"ISAM RPC タイムアウト"
31	"ISAM TCP/IP 接続が破壊されました。"
32	"ISAM サーバに接続できません。"
33	"ISAM データをインポートできません。"
34	"ローカル SAM デーモンはありません。"
35	"ISAM 致命的内部エラーです。"
36	"ISAM Locale/LANG が一致しません。"
$set 3
2	"子プロセス(%d)は、シグナル %d%s が原因で終了しました。"
3	" (コアダンプしました。)"
4	"子プロセス(%d)が終了せず、またシグナル発信もしません。"
5	"%m が原因でクライアントを最大表示できません。"
6	"管理する範囲がありません。-c、-p、-d のいずれかの\
オプションを使用するか、$DISPLAY を設定してください。"
7	"-S オプションは -c オプションと一緒に使用できません。"
8	"子 ttsession は、ステータス %d で終了しました。"
9	"子 ttsession は、シグナル %d%s が原因で終了しました。"
10	" (コアダンプしました。)"
11	"子 ttsession が終了せず、またシグナル発信もしません。"
12	"起動中"
13	"types を再読み込みします。"
14	"types にエラーがあります。\
旧 types を保持します。"
15	"$OPENWINHOME が設定されていません。"
16	"\n使用方法: ttsession [-a unix|des][-d display][-spStvhNX"
17	"][-c command]\n -c [command]\n\
プロセス・ツリー・セッションを起動し、そこでコマンドを実行します。\n\
後続のオプションは、コマンドに渡されます。\n\
デフォルト: $SHELL\n\
 -p		プロセス・ツリー・セッションを起動し、ID を出力します。\n\
 -d display	Ｘセッションをディスプレイ上で起動します。\n\n\
 -a unix|des	サーバの認証レベルを設定します。\n\
 -s		サイレント。警告をまったく出力しません。\n\
 -S		バックグラウンドにフォークしません。\n\
 -N		クライアントの数を指定可能な最大値にします。\n\
 -t		メッセージ・トレースをオンにします。\n\
 -X		静的 types (デフォルト)に XDR データベースを使用します。\n"
18	" -E		静的 types に分類機構を使用します。\n"
19	"\n\
 -v		バージョン番号を出力します。\n\
 -h		このメッセージを出力します。\n\n\
シグナル・インタフェース:\n\
 kill -USR1 ttsession_pid	メッセージ・トレースを切り替えます。\n\
 kill -USR2 ttsession_pid	静的 types を再読込みします。"
20	"終了中"
$set 4
2	"使用方法:\n\
tt_type_comp [-s] [-d db] [-mM] ソース・ファイル\n\
tt_type_comp [-s] [-d db] -r type ...\n\
-M	ソース types を指定したデータベースにマージします。既存の types は更新しません。\n\
-m	マージして、既存の types を更新します。デフォルトです。\n\
-r	ソース types を指定したデータベースから削除します。\n\
-d db	操作するデータベースです。\n\
	db には、user、system、network の中から 1 つを指定してください。\n\
	デフォルトは user です。\n\
-G	ToolTalk データベース・サーバ上で、不要部分を整理します。\n\n\
tt_type_comp [-sE] -p|O|P [-d db]\n\
tt_type_comp [-s]  -p|O|P コンパイル・ファイル\n\
-O	読み取ったすべての otype 名を標準出力にリストします。\n\
-P	読み取ったすべての ptype 名を標準出力にリストします。\n\
-p	読み取ったすべての ToolTalk types を整形して標準出力します。\n\
-E	分類機構データベースを XDR データベースの代わりに使用します。\n\
-d db	このデータベースから読み取ります。\n\
	  db には user、system、network の中から 1 つを指定します。\n\
	  デフォルトは all です。\n\n\
tt_type_comp [-s] -x [-o コンパイル・ファイル] ソース・ファイル\n\
-x	ソース・ファイル(または、ファイルを \"-\" と指定した場合には標準入力)\n\
	から types をコンパイルします。\n\
-o	コンパイルした types をコンパイル・ファイル(または、ファイルを\n\
	\"-\" と指定した場合には標準出力)に書き込みます。\n\
	デフォルト: ソース・ファイル.xdr、またはソースが標準入力の場合には\n\
	\"types.xdr\"\n\n\
tt_type_comp [-hv]\n\
-v	バージョン番号を出力します。\n\
-h	このメッセージを出力します。\n\
-s	ステータス・メッセージを出力しません。\n\n\
これらの cpp オプションは以下に渡されます:\n\
	-undef -Dname -Idirectory -Uname -Ydirectory"
3	"types ファイルに意味上のエラーがあります。"
4	"有効な ToolTalk types ファイルではありません。"
5	"分類機構データベースからどの ToolTalk types も読み取れません。"
6	"分類機構テーブルのマージは、サポートしていません。"
7	"%s データベースの types を読み取れません。バージョンが一致しません。"
8	"%s データベースの types を読み取れません。"
9	"$OPENWINHOME が設定されていません。"
10	"書き込み用の %s データベースを初期化できません。"
11	"%s の旧定義を削除できません。"
12	"上書き中です。"
13	"書き込み中です。"
14	"%s の新規定義を追加できません。"
15	"%s の旧定義を削除できません。"
16	"上書き中です。"
17	"書き込み中です。"
18	"%s の新規定義を追加できません。"
19	"コンパイルした types のバージョンが一致しません。"
20	"データベースの types を読み取れません。"
21	"$OPENWINHOME が設定されていません。"
22	"%s データベースの types を読み取れません。バージョンが一致しません。"
23	"%s データベースの types を読み取れません。"
24	"$OPENWINHOME が設定されていません。"
25	"otype %s を削除中です。\n"
26	"ptype %s を削除中です。\n"
27	"出力を %s に書き込みます。\n"
28	"データベース %s は無効です。"
29	"オプション -O、-P、-m、-M、-p、-r、-x の中から、\
オプションを 1 つだけ指定してください。"
30	"前処理は行われません。理由は次のとおりです: %s: %s"
31	"%s を含む otype 継承サイクル"
32	"otype %2$s の祖先 %1$s は存在しません。"
33	"ptype %s は存在しませんが、\
otype %s を実装するものとして名前を付けました。"
34	"otype %s で定義された複数のハンドラ"
35	"otype %s に継承されたシグニチャが親に存在しません。"
36	"同じハンドラを持つ、%s と %s の 2 つの ptypes が存在します。"
37	"otype %2$s の祖先 %1$s は存在しません。"
38	"循環する otype 継承階層 -\n  {"
39	"otype %s に重複する定義があります。"
40	"ptype %s に重複する定義があります。"
$set 5
3	"セキュリティ違反: RPC 呼び出しが、ToolTalk データベースではない\
ファイルを開こうとしました。"
4	"旧 rpc.ttdbserverd (<= 1.0.2)を使って書いたデータは、\
新 rpc.ttdbserverd (>= 1.1)を使った後はすべて無視されます。"
5	"旧 rpc.ttdbserverd (<= 1.0.2) を使って書いたデータは、\
新 rpc.ttdbserverd (>= 1.1) を使った後はすべて無視されます。"
6	"rpc.ttdbserverd バージョン (%s) が\
データベース・テーブルのバージョン(%s) と一致しません。\
rpc.ttdbserverd バージョン %s (またはそれ以降)をインストールしてください。"
7	"使用方法:\n\
rpc.ttdbserverd [-S] [-n] [-m DTMOUNTPOINT]\n\
rpc.ttdbserverd [-S] [-v]"
8	"不要部分の整理スレッドを開始できません。thr_create()\n"
9	"不要部分の整理の fork() ができません。\n"
$set 6
2	"使用方法:\n\
ttdbck [-f ファイル] [-k オブジェクトキー] [-t タイプ] [-bx] \n\
[-impa] [-IZ] [-F 新規ファイル名] [-T 新規タイプ] [マウント・ポイント]\n"
3	"ttdbck: 修復 [-FTZ] オプションを指定する場合は、\n\
選択 [-fkt] オプションまたは診断 [-bx] オプションを指定しなければなりません。"
4	"コンパイルした types のバージョンが一致しません。"
5	"データベースの types を読み取れません。"
6	"ttdbck: 'ttdbck -I' コマンドを実行してください。\n"
7	"ファイル名 %s で選択\n"
8	"オブジェクト ID キー で選択:"
9	"タイプ %s で選択\n"
10	"不正に形成されたエンティティを診断"
11	"存在しないエンティティへの参照を診断\n"
12	"ID を表示\n"
13	"必須データを表示\n"
14	"属性と値データを表示\n"
15	"検査する前に NetISAM isrepair() 関数を起動\n"
16	"タイプ %s に設定して修復\n"
17	"削除して修復\n"
18	"プリントアウト・レベル %d でデバッグ中です。\n"
19	"ファイル %s に設定して修復\n"
20	"エラー: 仕様のファイルがありません。\n"
21	"エラー: 仕様のタイプがありません。\n"
22	"エラー: \"%s\" はインストールした otype ではありません。\n"
23	"エラー: 仕様はタイプ属性に複数の値があります。\n"
24	"エラー: "
25	"ttdbck: エラーは見つかりません。\n"
26	"エラー: "
$set 7
2	"使用方法: %s {ctx}[fhpPv[v]] [tarfile] パス名 ...\n\
       %s {ctx}fL[hpPRv[v]] tttarfile パス名 ...\n\
       %s -v\n\
       %s -h\n"
3	"\tc       アーカイブを作成します。\n\
\tt       アーカイブの内容を表示します。\n\
\tx       アーカイブから抽出します。\n\
\tf       次の引き数 <tarfile> をアーカイブとして使用します。\n\
\th       シンボリック・リンクを辿ります。\n\
\tL       tar(1) を起動しません。\n\
\tp       ファイル・モードを保持します。\n\
\tP       (root) はオブジェクトの所有者、モード時間などを保持しません。\n\
\tR       ディレクトリに再帰しません。\n\
\tv       冗長にします。\n\
\tvv      非常に冗長にします。\n\
\t-v      バージョン番号を出力して終了します。\n\
\t-h[elp] このメッセージを出力します。\n"
4	"%s: アーカイブストリームからオブジェクトの種類を読み取れません。\n"
5	"%s: アーカイブストリームのアーカイブバージョンを読み取れません。\n"
6	"%s: アーカイブバージョン %d を見つけましたが、\n予期したバージョンは %d です。\n"
7	"%s: アーカイブに未知の種類のオブジェクト %d を見つけました。\n"
8	"%s: アーカイブストリームからオブジェクトの種類を読み取れません。\n"
9	"%s: アーカイブストリームからアーカイブバージョンを読み取れません。\n"
10	"%s: アーカイブバージョン %d を見つけましたが、\n\
予期したバージョンは %d です。\n"
11	"%s: アーカイブに未知の種類のオブジェクト %d を見つけました。\n"
$set 8
2	"%s: %s の ToolTalk オブジェクトを削除できません。原因は %s です。\n"
3	"%s: \"%s\" の ToolTalk オブジェクトを \"%s\" に移動できません。\n\
原因は %s です。\n"
4	"%s: \n の ToolTalk オブジェクトを移動しません。"
5	"使用方法: %s [-] [-fL] パス1 パス2\n\
       %s [-] [-fL] パス1 [パス2 ...] ディレクトリ\n\
       %s -v\n\
       %s -h\n"
6	"\t-L      mv(1) を実行しないでください。\n\
\t-v      バージョン番号を出力して終了します。\n\
\t-h      このメッセージを出力します。\n"
7	"%s: %s の ToolTalk オブジェクトを削除できません。原因は %s です。\n"
8	"使用方法: %s [-] [-%s] %s ...\n       %s -v\n\       %s -h\n"
9	"ファイル"
10	"ディレクトリ"
11	"\t-L      %s(1) を実行しないでください。\n\
\t-v      バージョン番号を出力して終了します。\n\
\t-h[elp] このメッセージを出力します。\n"
12	"%s: %s の ToolTalk オブジェクトを削除できません。原因は %s です。\n"
13	"使用方法: %s [-pL] ファイル1 ファイル2\n\
       %s [-prRL] パス1 [パス2 ...] ディレクトリ\n\
       %s -v\n\
       %s -h\n"
14	"\t-L      cp(1) を実行しないでください。\n\
\t-v      バージョン番号を出力して終了します。\n\
\t-h      このメッセージを出力します。\n"
$set 9
2	"使用方法: %s [-0FCa][-o 出力ファイル] [-S セッション | コマンド [オプション]]\n\
       %s [-e スクリプト | -f スクリプトファイル][-S セッション | コマンド [オプション]]\n\
 -0		セッションのメッセージ・トレースをオフにするか、または、\n\
		コマンドをメッセージ・トレースなし(すなわち API トレース\n\
		のみ)で実行します。\n\
 -F		コマンドがフォークしたすべての子プロセス、または、\n\
		ttysession(1) がセッション内で続けて起動したすべての子を\n\
		辿ります。\n\
 -C		ToolTalk API 呼び出しをトレースしません。\n\
 -a		トレースしたメッセージの属性、引き数、およびコンテキスト・\n\
		スロットをすべて出力します。デフォルトは単一行サマリです。\n\
 -e スクリプト	スクリプトから tttracefile(4) 設定を読み込みます。\n\
 -f スクリプトファイル\n\
		スクリプト・ファイルから tttracefile(4) 設定を読み込みます。\n\
		\"-\": 標準入力\n\
 -o 出力ファイル\n\
		出力。\"-\": 標準出力。デフォルトでは、セッション・トレース\n\
		は標準出力で、コマンド・トレースは ttrace の標準エラー出力です。\n\
 -S セッション	トレースするセッション。\n\
		デフォルトでは、tt_default_session() を参照します。\n\
コマンド	起動およびトレースを行なう ToolTalk クライアント・コマンド。\n"
3	"%s: セッション <%s> は Session_Trace をサポートしません。代わりに、\n\
kill -USR1 コマンドを使用してください。ttsession(1) を参照してください。\n"
$set 10
2	"Tts_address::add() に渡された未知の Tt_adress を無視します。\n"
3	"Tts_address::remove() に渡された未知の Tt_adress を無視します。\n"
4	"tts_address::tts_set() に渡された未知のアドレスを無視します。\n"
5	"tts_address::tts_unset() に渡された未知のアドレスを無視します。\n"
6	"tts_address::load() が読み取った未知のアドレスを無視します。\n"
7	"Tts_arglist::Tts_arglist - 引き数の読み込みエラー - \n\t"
8	"Tts_arglist::load - 未知の arg 型が見つかりました。BARG を使用します。\n"
9	"Abstract class Tts_arg::assign (Tt_pattern) が呼び出されました。無視します。\n"
10	"Abstract class Tts_arg::assign(Tt_message) が呼び出されました。無視します。\n"
11	"Abstract class Tts_arg::generate が呼び出されました。無視します。\n"
12	"Abstract class Tts_arg::save が呼び出されました。無視します。\n"
13	"Abstract class Tts_arg::load が呼び出されました。無視します。\n"
14	"Tts_arg::mode_to_chars が無効なモードです。TT_INOUT を使用します。\n"
15	"Tts_arg::chars_to_mode が無効なモードです。TT_INOUT を使用します。\n"
16	"Tts_category::set() に渡された未知の Tt_category を無視します。\n"
17	"Tts_category::generate() がメッセージを呼び出しました。無視します。\n"
18	"tts_category::load() が読み取った未知のカテゴリを無視します。\n"
19	"Tts_class::add() に渡された未知の Tt_class を無視します。\n"
20	"Tts_class::remove() に渡された未知の Tt_class を無視します。\n"
21	"tts_class::tts_set() に渡された未知のクラスを無視します。\n"
22	"tts_class::tts_unset() に渡された未知のクラスを無視します。\n"
23	"tts_class::load() が読み取った未知のクラスを無視します。\n"
24	"Tts_connection::universal_callback - パターンを形成する\n\
パターンはありません。\n"
25	"Tts_cntxtlist::Tts_cntxtlist - コンテキストの読み込みエラー - \n\t"
26	"Tts_contextlist::load - 未知の cntxt 型が見つかりました。\n\
BCNTXT を使用します。\n"
27	"Abstract class Tts_context::assign (Tt_pattern) が呼び出されました。無視します。\n"
28	"Abstract class Tts_context::assign (Tt_pattern) が呼び出されました。無視します。\n"
29	"Abstract class Tts_context::generate が呼び出されました。無視します。\n"
30	"Abstract class Tts_context::save が呼び出されました。無視します。\n"
31	"Abstract class Tts_context::load が呼び出されました。無視します。\n"
32	"Tts_disposition::add() に渡された未知の Tt_disposition を無視します。\n"
33	"Tts_disposition::remove() に渡された未知の Tt_disposition を無視します。\n"
34	"tts_disposition::tts_set() に渡された未知の処置を無視します。\n"
35	"tts_disposition::tts_unset() に渡された未知の処置を無視します。\n"
36	"tts_disposition::load() が読み取った未知の処置を無視します。\n"
37	"%s を呼び出しました。\n"
38	"ToolTalk エラー: %s\n        起点: ソース・ファイル %s の %d 行\n"
39	"警告: %s\n        起点: ソース・ファイル %s の %d 行\n"
40	"Tts_message_molding::send - 初期化していないメッセージ形成を送信しようとしました。\n"
41	"Tts_scope::add() に渡された未知の Tt_scope を無視します。\n"
42	"Tts_scope::remove() に渡された未知の Tt_scope を無視します。\n"
43	"tts_scope::tts_set() に渡された未知の配信範囲を無視します。\n"
44	"tts_scope::tts_unset() に渡された未知の配信範囲を無視します。\n"
45	"tts_scope::load() が読み取った未知の配信範囲を無視します。\n"
46	"Tts_state::add() に渡された未知の Tt_state を無視します。\n"
47	"Tts_state::remove() に渡された未知の Tt_state を無視します。\n"
48	"tts_state::tts_set() に渡された未知の状態を無視します。\n"
49	"tts_state::tts_unset() に渡された未知の状態を無視します。\n"
50	"Tts_state::generate() がメッセージを呼び出しました。無視します。\n"
51	"tts_state::load() が読み取った未知の状態を無視します。\n"
82	"TTSnoop ヘルプの参照"
83	"--------------------"
84	"個々のボタンおよび設定のヘルプは、マウスがそのボタンの上にある時に"
85	"ヘルプ・キーを押すこと、あるいは配信対象を設定することによって"
86	"参照できます。ttsnoop がどの API 呼び出しを使用しているかを調べるには、"
87	"ttsnoop を起動する際に -t スイッチを使用してください。"
88	""
89	"TTSnoop の使い方"
90	"----------------"
91	"メッセージを監視するには、設定選択の [開始] を選択してください。"
92	""
93	"メッセージの監視をオフにするには、設定選択の [中止] を選択してください。"
94	""
95	"メッセージのタイプを制限するには:"
96	"      1) [パターン] ボタンを選択します。"
97	"      2) 監視したいパターンのタイプを入力します。"
98	"      3) [適用] ボタンを選択します。"
99	""
100	"表示する情報を強調表示するには:"
101	"      1) [表示] ボタンを選択します。"
102	"      2) 強調表示したい項目をマークします。"
103	"      3) [適用] ボタンを選択します。"
104	""
105	"メッセージを送信するには:"
106	"      1) [メッセージ] ボタンを選択します。"
107	"      2) メッセージを作成します。"
108	"      3) [メッセージの送信] ボタンを選択します。"
109	""
110	"メッセージを格納するには:"
111	"      1) [メッセージ] ボタンを選択します。"
112	"      2) メッセージを作成します。"
113	"      3) [メッセージの追加] ボタンを選択します。"
114	""
115	"格納したメッセージを送信するには:"
116	"      [メッセージの送信] メニューでメッセージを選択します。"
117	""
118	"メッセージ出力ウィンドウを消去するには、[消去] ボタンを選択してください。"
119	""
120	"一般 ToolTalk 情報"
121	"------------------"
122	"ToolTalk を介してオブジェクト指向メッセージを送信または受信"
123	"する前に、プロセスはメッセージ・パサーに登録しなければなり"
124	"ません。登録によって、プロセスは ToolTalk にいくつかの事項を"
125	"通知します:"
126	""
127	"      プロセスのプロセス・タイプ(ptype)。"
128	"      これにより、メッセージ・パサーは、"
129	"      この ptype が実装したメッセージを"
130	"      このプロセスに指示できます。"
131	""
132	"      プロセスが参加するセッション。"
133	""
134	"      プロセスが監視しているドキュメント。"
135	"      これらのドキュメントの中のオブジェクト"
136	"      へのメッセージをプロセスへ送るように"
137	"      送信経路を決定できます。"
138	""
139	"これらの登録は、通常生成パターンを変更"
140	"することに注意してください。パターン操作"
141	"API 呼び出しを、オブジェクト指向メッセージ"
142	"を監視または処理するために使用できますが、"
143	"ここで述べる方法はもっと短いので、タイプ"
144	"定義内で宣言された情報を処理するには有利"
145	"です。"
146	""
147	"セッションに参加するには、tt_session_join を使用"
148	"してください。参加する際には、参加するセッションの"
149	"セッション ID を指定しなければなりません。"
150	""
151	"ツールが ToolTalk サービスを必要としなくなった場合は"
152	"tt_session_quit を使ってセッションを終了してください。"
153	""
154	"ツールがファイルを読み込む時は、tt_file_join() を"
155	"呼び出して、ファイル内の処理の対象となる一連のプロセス"
156	"に参加しなければなりません。ファイルを終了する場合は、"
157	"tt_file_quit() を呼び出して、一連のプロセスを終了して"
158	"ください。ツールによっては、複数のファイルを一度に開き"
159	"ます。一度に 1 個だけファイルを開くツールもあります。"
160	"TTSnoop の使い方"
161	"----------------"
162	"メッセージを監視するには、設定選択の [開始] を選択してください。"
163	"メッセージの監視をオフにするには、設定選択の [中止] を選択してください。"
164	""
165	"メッセージのタイプを制限するには:"
166	"        1) [パターン] ボタンを選択します。"
167	"        2) 監視したいパターンのタイプを入力します。"
168	"        3) [適用] ボタンを選択します。"
169	""
170	"表示する情報を強調表示するには:"
171	"        1) [表示] ボタンを選択します。"
172	"        2) 強調表示したい項目をマークします。"
173	"        3) [適用] ボタンを選択します。"
174	""
175	"メッセージを送信するには:"
176	"        1) [メッセージ] ボタンを選択します。"
177	"        2) メッセージを作成します。"
178	"        3) [メッセージの送信] ボタンを選択します。"
179	""
180	"メッセージを格納するには:"
181	"        1) [メッセージ] ボタンを選択します。"
182	"        2) メッセージを作成します。"
183	"        3) [メッセージの追加] ボタンを選択します。"
184	""
185	"格納したメッセージを送信するには:"
186	"        [メッセージの送信] メニューでメッセージを選択します。"
187	""
188	"メッセージ出力ウィンドウを消去するには、[消去] ボタンを選択してください。"
189	""
190	"一般 ToolTalk 情報"
191	"------------------"
192	"ToolTalk を介してオブジェクト指向メッセージを送信または受信する"
193	"前に、プロセスはメッセージ・パサーを使って登録しなければなりません。"
194	"登録によって、プロセスは ToolTalk にいくつかの事項を通知します:"
195	""
196	"        プロセスのプロセス・タイプ(ptype)。これにより、"
197	"        メッセージ・パサーは、この ptype が実装した"
198	"        メッセージをこのプロセスに指示できます。"
199	""
200	"        プロセスが参加するセッション。"
201	""
202	"        プロセスが監視しているドキュメント。これらの"
203	"        ドキュメントの中のオブジェクトへのメッセージを"
204	"        プロセスへ送るよう送信経路を決定できます。"
205	""
206	"これらの登録は通常生成パターンを変更することに注意して"
207	"ください。パターン操作 API 呼び出しをオブジェクト指向"
208	"メッセージを監視または処理するために使用できますが、"
209	"ここで述べる方法はもっと短いので、タイプ定義内で宣言された"
210	"情報を処理するには有利です。"
211	""
212	"セッションに参加するには、tt_session_join を使用してください。参加する"
213	"際には、参加するセッションのセッション ID を指定しなければなりません。"
214	""
215	"ツールが ToolTalk サービスを必要としなくなった場合は、"
216	"tt_session_quit を使ってセッションを終了してください。"
217	""
218	"ツールがファイルを読み込む時は、tt_file_join() を呼び出して、ファイル内"
219	"の処理の対象となる一連のプロセスに参加しなければなりません。ファイルを"
220	"終了する場合は、tt_file_quit() を呼び出して、一連のプロセスを終了して"
221	"ください。ツールによっては、複数のファイルを一度に開きます。一度に 1 個"
222	"だけファイルを開くツールもあります。"
223	"メッセージの受信および表示を開始/中止"
224	"メッセージ・ウィンドウを消去"
225	"表示"
226	"----"
227	"プロセスのメッセージが到着すると、ファイル記述子がアクティブになり"
228	"ます。ツールに固有の構造によって、ファイル記述子がアクティブになった"
229	"時にウィンドウ・システム・ツールキットがコールバックを呼び出すように"
230	"配置するか、多くのファイル記述子をブロックする select(3) 呼び出しに"
231	"ファイル記述子を含めることができます。"
232	"どちらの場合でも、ファイル記述子がアクティブになった後に、"
233	"tt_message_receive() を呼び出して着信メッセージを含むメッセージの"
234	"ハンドルを取得します。tt_message_*() 呼び出しを使用して、実行する"
235	"アクションを決定するためにメッセージの属性を調べることができます。"
236	"ハンドルを比較する、tt_message_user_set() 呼び出しを用いてメッセージ"
237	"内にアプリケーションにとって有意な情報を入れる、あるいは"
238	"tt_message_callback_add 呼び出しおよび tt_pattern_callback_add 呼び"
239	"出しを使って、メッセージおよびパターン上に特定のコールバックを入れる"
240	"ことによって、送信したメッセージに対する返信を認識できます。"
241	"メッセージ"
242	"----------"
243	"メッセージを送信するには、まず新規メッセージを割り当てて適切な情報を"
244	"入力した後で、送信してください。返信が同じメッセージ内に現れます。"
245	"メッセージが終了した時は、メッセージの記憶領域を開放してください。"
246	"(要求を返す値は、必要な戻り値をコピーした後に開放してください。"
247	"通知は、送信後直ちに開放してください。)"
248	""
249	"新規メッセージを割り当てるには、tt_message_create() を使用してください。"
250	"これは、\"ハンドル\" または \"隠されたポインタ\" をメッセージに返します。"
251	"このハンドルを後続の呼び出しに使用して、このメッセージを参照してください。"
252	""
253	"メッセージ情報を記入するには、tt_message_*_set() 呼び出しを使用してくだ"
254	"さい。この呼び出しは、メッセージの各属性ごとに一つずつあります。"
255	""
256	"クラス、アドレス、Op、および Args を設定してください。"
257	""
258	"tt_message_send() を使ってメッセージを送信してください。"
259	"パターン"
260	"--------"
261	"送信プロセスが特定の受信側を明示的に指定しない限り、受信側を"
262	"決定するのに \"パターン・マッチング\" 法を使用します。"
263	"ツールは配信するメッセージの記述を登録し、ToolTalk は"
264	"これらのメッセージ記述を使用してメッセージの送信経路を推論"
265	"します。別のパターンセットを保持することによって、ツールで"
266	"処理したいメッセージと、ツールで監視したいメッセージを記述し"
267	"ます。メッセージを受信したいツールでは、配信対象を実行時に"
268	"動的に宣言するか、インストール時に静的に宣言します。動的登録"
269	"は、すべてのメッセージを比較するためのパターンで構成されて"
270	"います。メッセージがパターンと一致した場合には、パターンを登録"
271	"したツールにメッセージを受信する資格があります。"
272	""
273	"ToolTalk を介して手続き型メッセージを受信する前に、メッセージ・"
274	"パサーを使ってプロセスを登録してください。登録によって、プロセスは"
275	"ToolTalk にパターンを与え、ToolTalk はこれらのパターンに一致する"
276	"メッセージをプロセスに発信します。パターンは、2 つの方法で作成できます。"
277	""
278	"静的方法。ptype を介します。プロセスはその ptype をメッセージ・パサーに"
279	"宣言できます。次に、ToolTalk は ptype の各シグニチャからパターンを生成"
280	"します。これらの生成パターンは、オブジェクト指向メッセージを渡すときと"
281	"同様に、セッションとファイルを結合または終了することによって変更できます。"
282	""
283	"動的方法。プロセスはパターン \"on the fly\" を作成し、ToolTalk"
284	"に登録します。この機能は一般的には、送信するメッセージを監視して"
285	"ウィンドウに表示するというメッセージのログを取るユーティリティ"
286	"として使用します。このようなユーティリティは、メッセージ・プロト"
287	"コルのデバッグに役立ちます。"
288	""
289	"このアプリケーションは、動的パターンのみを使用します。"
290	""
291	"パターンを登録するには、まず新規パターンを割り当てて適切な情報を"
292	"入力してから登録してください。パターンを終了する時は(パターンと"
293	"一致するメッセージが必要なくなった時のみ)、そのパターンの記憶領域を"
294	"開放してください。"
295	""
296	"新規パターンを割り当てるには、tt_pattern_create() を使用してください。"
297	"これは \"ハンドル\" または \"隠されたポインタ\" をパターンに返します。"
298	"このハンドルを後続の呼び出しに使用して、このメッセージを参照してください。"
299	""
300	"パターン情報を入力するには、tt_pattern_*_add() 呼び出しを使用してくだ"
301	"さい。この呼び出しは、パターンの各属性に対して一つずつあります。パターン"
302	"の各属性に、複数の値を指定することもできます。パターンの値がメッセージの"
303	"値と一致する場合は、パターン属性はメッセージ属性と一致します。"
304	""
305	""
306	"このアプリケーションは、非排他的設定と、複数の属性に対するコンマで"
307	"区切られた値を使用します。"
308	""
309	"メッセージを、特定の属性の値に関係なく一致させるには、パターンの属性を"
310	"省略してください。"
311	""
312	"パターン属性を指定しなければ、ToolTalk サービスはメッセージ属性を"
313	"一致するとします。指定するパターン属性が少なければ少ない程、受信"
314	"可能なメッセージは多くなります。"
315	""
316	"パターン属性に複数の値が指定されている場合は、値の 1 つがメッセージ"
317	"属性値と一致しなければなりません。一致する値がない場合は、ToolTalk"
318	"サービスは、アプリケーションを受信側と見なしません。"
319	""
320	"属性の [カテゴリ] と [配信範囲] は常に指定しなければなりません。"
321	""
322	"パターンが完了したら、tt_pattern_register() を使用して登録した後で、"
323	"[適用] ボタンを '選択' して必要に応じてセッションまたはファイルを"
324	"結合してください。"
325	""
326	"ファイルおよびセッションの結合の主要な効果は、現在の登録パターンを"
327	"更新することなので、結合後に登録されたパターンは更新されません。"
328	"結合前にすべてのパターンを登録するか、新規パターンの登録後に結合を"
329	"実行しなおさなければなりません。これは、ptype を結合して明示的に"
330	"登録したパターンにも適用されます。メッセージ・ウィンドウを介して"
331	"メッセージを追加した場合は、このボタンに接続したメニューが表示され"
332	"ます。このメニューを選択すれば、メッセージを送信できます。"
333	"アドレス:"
334	"多くのツールのタイプがあり、様々なユーザが様々なツールセットを様々"
335	"な時に使用するので、メッセージの発信側にとって、メッセージの受信側を"
336	"正確に識別することは、しばしば不可能です。"
337	"代わりに、送信側はメッセージの意味を指定する操作名を与え、メッセージの"
338	"宛先のオブジェクトまたはオブジェクト型(otype)を与える場合もあります。"
339	""
340	""
341	"オブジェクト指向メッセージには、オブジェクトまたは otype を使用してください。"
342	"アドレスがハンドラの場合は、ハンドラを指定してください。"
343	""
344	"        TT_PROCEDURE: Op および Args が指定されました。"
345	""
346	"        TT_OBJECT:    オブジェクト、Op、および Args が指定されました。"
347	""
348	"        TT_HANDLER:   ハンドラ、Op、および Args が指定されました。"
349	""
350	"        TT_OTYPE:     otype、Op、および Args が指定されました。"
351	"ハンドラ:  "
352	"ハンドラの正確な procid がわかっている場合は、メッセージをそこに"
353	"直接アドレスできます。通常の方法では、これは 1 つのプロセスに"
354	"対して一般的要求を行った後、返信からハンドラ属性を取り出して同じ"
355	"ハンドラに追加メッセージを指示します。これにより 2 つのプロセスは、"
356	"渡されるブロードキャストメッセージを介して認識しあってからダイアログ"
357	"に入ることができます。"
358	"Handler_Ptype:"
359	"メッセージを処理するプロセスの ptype がわかっている場合は、その値を"
360	"入力してください。プロトコルの詳細を理解するために ptype 定義を調べ"
361	"ると、ptype がわかります。"
362	"オブジェクト:"
363	"メッセージを送信するオブジェクトの objid を入力してください。"
364	"OType:"
365	"オブジェクト型"
366	"Op:"
367	"実行する通知または要求を記述する操作を入力してください。"
368	"操作名を決定するには、ターゲット・オブジェクトの otype 定義を"
369	"調べてください。"
370	"Opnum:"
371	"操作番号。これは、過負荷操作(同名で、異なる引き数型を持つ操作)を"
372	"識別するためと、クライアントの \"内部\" ディスパッチ(適切な内部"
373	"プロシージャを指定されたメッセージに対して起動する)を簡略化する"
374	"ために使用します。"
375	"配信範囲:"
376	"同じセッションに他のプロセスからのメッセージがある場合は、プロセス"
377	"の必要に応じて、配信範囲セッションを使用してください。ファイルに関する"
378	"メッセージが必要な場合は、配信範囲ファイルを使用してください。"
379	""
380	"      TT_SESSION:          セッション内の他のプロセスからのメッセージ"
381	"                           を受信します。"
382	""
383	"      TT_FILE:             結合ファイルに関するメッセージを受信します。"
384	""
385	"      TT_BOTH:             ファイルとセッションに関するメッセージを"
386	"                           受信します。"
387	""
388	"      TT_FILE_IN_SESSION:  このセッション中に結合されたファイルの"
389	"                           メッセージを受信します。"
390	"セッション:"
391	"配信範囲セッションの場合は、セッション(デフォルトでは"
392	"tt_default_session())を指定してください。"
393	"ファイル:"
394	"ファイル配信範囲の場合は、ファイル名を指定してください。"
395	"カテゴリ:"
396	"メッセージの参照だけの場合は、カテゴリ監視を使用してください。カテゴリ・"
397	"ハンドルを使用して、メッセージの一意のハンドラにしてください。"
398	""
399	"    TT_OBSERVE: 監視しているプロセスは、それ自体の情報に関するメッセージ"
400	"                のコピーを取得するだけです。いくつのプロセスでも、メッセ"
401	"                ージを監視できます。メッセージが要求の場合でさえ、オブザ"
402	"                ーバは送信側に値を返すことはできません。オブザーバが行な"
403	"                うアクションは、基本的ツール・データの対話形式による表示"
404	"                のみに影響を与える場合が多いです。"
405	""
406	"    TT_HANDLE:  ハンドリング・プロセスは、実際にはメッセージに基づく"
407	"                アクションを実行します。1 つのプロセスだけが、与え"
408	"                られたメッセージを処理します。メッセージが要求の場合は"
409	"                ハンドリング・プロセスは、任意の値を返すプロセスです。"
410	"                一般的には、ハンドラの行なうアクションは、ツール・"
411	"                データの格納されている固定表示に影響を及ぼします。"
412	"クラス:"
413	"値を返すメッセージ、あるいはメッセージを処理またはキューに登録した時に"
414	"通知するフィードバックが欲しいメッセージに対しては、メッセージのクラス"
415	"要求を使用してください。イベントを他のプロセスに通知するのみの"
416	"メッセージに対しては、クラス通知を使用してください。"
417	""
418	"    TT_NOTICE:   通知は、他のツールにイベントの発生を知らせる"
419	"                 メッセージです。通知を送信するツールは、返信を"
420	"                 予期しません。送信側は何かの発生を他のツールに"
421	"                 知らせるだけです。"
422	""
423	"     TT_REQUEST: 要求は、他のツールにアクションの実行を要求する"
424	"                 メッセージです。要求ツールは、値が返されることを"
425	"                 いつもではありませんが、しばしば期待しています。"
426	"                 この値は、要求に対する返信として返されます。値が"
427	"                 返されない場合でさえも、要求を処理するツールは、"
428	"                 正常終了または異常終了を示す返信を送信します。"
429	"処置:"
430	"実行中のプロセスが、どれもメッセージを処理できない場合に、実行する"
431	"アクションを指定します。Handler_Ptype のプロセスを登録するまで、メッ"
432	"セージをキューに登録しなければならない場合には、キューに登録します。"
433	"Handler_Ptype のプロセスを起動しなければならない場合は、起動します。"
434	""
435	"    TT_QUEUE: 適切な ptype のプロセスがメッセージを受信するまで、"
436	"              メッセージをキューに登録します。"
437	""
438	"    TT_START: 何も実行中でない場合に適切な ptype のプロセスを起動"
439	"              しようとします。"
440	""
441	"Tt_disposition 値は、1 つにまとめることができるので、"
442	"TT_QUEUE+TT_START は、メッセージをキューに登録することと、プロセスを"
443	"起動しようとすることの両方を指示することに注意してください。これは、"
444	"起動が失敗(またはユーザが拒否)できる場合に、適切なプロセスを起動した"
445	"直後にメッセージを処理することを保証できるので役立ちます。"
446	"状態:"
447	"メッセージの状態属性の値。"
448	"可能な値とその意味を以下に示します。"
449	""
450	"    TT_CREATED:  メッセージを作成しましたが、まだ送信していません。"
451	"                 メッセージの送信側のみがこの状態のメッセージを見られます。"
452	""
453	"    TT_SENT:     メッセージを送信しましたが、まだ処理していません。"
454	""
455	"    TT_HANDLED:  メッセージを処理しました。戻り値は有効です。"
456	""
457	"    TT_FAILED:   メッセージをハンドラに配信できません。"
458	""
459	"    TT_QUEUED:   メッセージを後で配信するために、キューに登録しました。"
460	""
461	"    TT_STARTED:  このメッセージを処理するプロセスを開始中です。"
462	""
463	"    TT_REJECTED: 可能なハンドラが、メッセージを拒否しました。"
464	"                 この状態は、プロセスが拒否している時のみに見られます。"
465	"                 ToolTalk は状態を、別の可能なハンドラにメッセージを"
466	"                 発信する前に、TT_SENT に戻します。"
467	"ステータス:"
468	"受信側が返すメッセージの結果を示す一意の番号。"
469	"この番号は TT_ERR_LAST (2047)より大きくなければなりません。"
470	"ステータス文字列:"
471	"メッセージのステータスのテキスト説明。"
472	"送信側:"
473	"メッセージを送信したプロセスを識別します。"
474	"送信側 ptype:"
475	"メッセージを送信したプロセスの ptype。"
476	"Uid:"
477	"メッセージを送信したプロセスの有効なユーザ識別子。"
478	"Gid:"
479	"メッセージを送信したプロセスの有効なグループ識別子。"
480	"モード:"
481	"メッセージ引き数のモードを指定します。"
482	"可能な値と意味は以下のとおりです。"
483	""
484	"    TT_IN:    引き数は送信側によって書き込まれ、ハンドラおよび"
485	"              任意のオブザーバによって読み取られます。"
486	""
487	"    TT_OUT:   引き数はハンドラによって書き込まれ、送信側および"
488	"              任意の応答オブザーバによって読み取られます。"
489	""
490	"    TT_INOUT: 引き数は書き込まれ、送信側、ハンドラおよび任意の"
491	"              オブザーバによって読み取られます。"
492	"タイプ:"
493	"タイプを示す文字列。開発者は独自の値を作成できますが、共通の値は、"
494	"\"string\" と \"int\" です。"
495	"値:"
496	"タイプに依存する実際のデータの値。"
497	"[適用] ボタンを押すと、各受信メッセージに関する指定した設定の値が"
498	"表示されます。"
499	"押すと、表示の値が最後に適用した状態か、初期値のどちらか最新の方に"
500	"リセットします。"
501	"受信コンテキストの編集:"
502	"受信したいコンテキストを追加、削除、または変更します。"
503	"パターン・マッチャー"
504	"------------------"
505	"送信プロセスが特定の受信側を明示的に指示しない限り、受信"
506	"側を決定するのに \"パターン・マッチング\" 法を使用します。"
507	"ツールでは配信するメッセージの記述子を登録して、ToolTalk"
508	"がこれらのメッセージ記述子を使用してメッセージの経路指定"
509	"を推論します。パターンの別のセットを保持することによって、"
510	"ツールで処理したいメッセージと、ツールで監視したいメッセ"
511	"ージを記述します。メッセージを受信したいツールでは、配信"
512	"対象を実行時に動的に宣言するか、インストール時に静的に宣"
513	"言します。動的登録では、すべてのメッセージを、それに対し"
514	"て比較するパターンを含みます。メッセージがパターンと一致"
515	"した場合には、パターンを登録したツールに、メッセージを受"
516	"信する資格があります。"
517	""
518	"ToolTalk を介してプロシージャ・メッセージを受信する前に、メッセ"
519	"ージ・パサーを登録してください。登録によって、プロセスはパター"
520	"ンを ToolTalk に与え、ToolTalk はメッセージをパターンに一致する"
521	"プロセスに発信します。パターンは、2 つの方法で作成できます。"
522	""
523	"静的パターンでは、 ptype を介してプロセスはその ptype をメッセージ・"
524	"パサーに宣言します。次に、ToolTalk が各シグニチャからパターンを ptype"
525	"に出力します。この出力パターンは、セッションとファイルを結合または終了"
526	"することによって変更でき、オブジェクト指向メッセージとして渡されます。"
527	""
528	"動的パターンでは、プロセスはパターン \"on the fly\" を作成し、ToolTalk"
529	"に登録します。この機能の一般的な使い方は、メッセージ・ログイン・"
530	"ユーティリティです。これは、送信するメッセージを監視してウィンドウに"
531	"表示します。このようなユーティリティは、メッセージ・プロトコルの"
532	"デバッグに役立ちます。"
533	""
534	"このアプリケーションは、動的パターンのみを使用します。"
535	""
536	"パターンを登録するには、まず新規パターンを割り当てて、適切な情報を"
537	"入力してください。パターンとの関連を切る時(これはメッセージが"
538	"もはや必要ではなくなった時です)時には、そのパターンの記憶領域を"
539	"開放してください。"
540	""
541	"新規パターンを割り当てるには、tt_pattern_create() を使用してください。"
542	"これは \"ハンドル\" または \"隠されたポインタ\" をパターンに返します。正常"
543	"終了する呼び出しが、このパターンを表すようにこのハンドルを使用してください。"
544	""
545	"パターン情報を入力するには、tt_pattern_*_add() 呼び出しを使用して"
546	"ください。パターンの各属性に対してひとつずつあります。"
547	"パターンの各属性に、複数の値を指定できます。パターンの値がメッセージ"
548	"の値と一致する場合には、パターン属性はメッセージ属性と一致します。"
549	""
550	""
551	"このアプリケーションは、非排他的設定と、複数の属性に対するコンマで"
552	"区切られた値を使用します。"
553	""
554	"メッセージを、特定の属性値を考慮をせずに一致させるには、パターンの属性"
555	"を省略してください。"
556	""
557	"パターン属性を指定しなければ、ToolTalk サービスはメッセージ属性を"
558	"一致するとカウントします。指定するパターン属性が少なければ少ない程、"
559	"受信に適したメッセージは多くなります。"
560	""
561	"パターン属性に複数の値が指定されている場合は、値の 1 つがメッセージ"
562	"属性値と一致しなければなりません。一致する値がない場合には、ToolTalk"
563	"サービスは、アプリケーションを受信側として考慮しません。"
564	""
565	"属性のカテゴリと範囲は常に指定しなければなりません。"
566	""
567	"パターンが完了したら、tt_pattern_register() を使用して登録した"
568	"後で、セッションまたはファイルを、[適用] ボタンを '選択' して要求した"
569	"ものとして結合してください。"
570	""
571	"ファイルおよびセッションの結合の主要な効果は、現在の登録"
572	"パターンを更新することなので、結合後に登録されたパターンは"
573	"更新されません。結合前にすべてのパターンを登録するか、"
574	"新規パターンの登録後に、結合を再実行しなければなりません。"
575	"これは、ptype を結合して、明示的に登録したパターンだけに"
576	"適用されます。"
577	"アドレス:"
578	"ツールのタイプは多く、別のユーザは、別のツール・セット"
579	"を別の時に使用するので、メッセージの発信側にとって、"
580	"メッセージの受信側を正確に識別することは、しばしば"
581	"不可能です。代わりに、送信側はメッセージの意味を指定"
582	"する操作名を、メッセージの宛先のオブジェクトまたは"
583	"オブジェクト型(otype)に与えます。"
584	""
585	"オブジェクトまたはオブジェクト指向メッセージを使用してください。"
586	"アドレスがハンドラの場合には、ハンドラを指定してください。"
587	""
588	"    TT_PROCEDURE: Op および Args が指定されました。"
589	""
590	"    TT_OBJECT:    オブジェクト、Op、および Args が指定されました。"
591	""
592	"    TT_HANDLER:   ハンドラ、Op、および Args が指定されました。"
593	""
594	"    TT_OTYPE:     otype、Op、および Args が指定されました。"
595	"オブジェクト:"
596	"メッセージの送信先オブジェクトの objid を入力してください。"
597	"OType:"
598	"オブジェクトの型"
599	"Op:"
600	"行われる通知または要求を記述する操作を入力してください。"
601	"ターゲット・オブジェクトの otype 定義を調べて、操作名を"
602	"決定してください。"
603	"範囲:"
604	"同じセッションに他のプロセスからのメッセージがある場合には、プロセス"
605	"の必要に応じて、範囲セッションを使用してください。ファイルに関する"
606	"メッセージが必要な場合には、範囲ファイルを使用してください。"
607	""
608	"    TT_SESSION:          セッション内の他のプロセスからのメッセージを"
609	"                         受信します。"
610	""
611	"    TT_FILE:             結合したファイルに関するメッセージを受信します。"
612	""
613	"    TT_BOTH:             ファイルおよびセッションに関するメッセージを受信します。"
614	""
615	"    TT_FILE_IN_SESSION:  このセッションの中で結合したファイルに関する"
616	"                         メッセージを受信します。"
617	"ファイル:"
618	"ファイル範囲には、ファイルの名前を指定してください。"
619	"セッション:"
620	"範囲セッションには、セッション(デフォルトでは、tt_default_session())"
621	"を指定してください。"
622	"カテゴリ:"
623	"メッセージを参照するだけの場合には、カテゴリ監視を使用してください。"
624	"カテゴリ・ハンドルを使用して、メッセージの一意のハンドラにしてください。"
625	""
626	"    TT_OBSERVE: 監視するプロセスは、それ自体の情報に関するメッセージの"
627	"                コピーを取得します。プロセスの番号で、メッセージを監視"
628	"                できます。メッセージが要求の場合でさえ、オブザーバは"
629	"                送信側に値を返すことができません。オブザーバの行う"
630	"                アクションは、しばしば基本的ツール・データの対話表示"
631	"                にだけ影響を与えます。"
632	""
633	"    TT_HANDLE:  ハンドリング・プロセスは、実際にはメッセージに基づく"
634	"                アクションを実行します。1 つのプロセスだけが、与え"
635	"                られたメッセージを処理します。メッセージが要求の場合は"
636	"                ハンドリング・プロセスは、任意の値を返します。"
637	"                一般的には、ハンドラの行うアクションは、ツールの"
638	"                データの永久記憶表現に反映します。"
639	"クラス:"
640	"値を返すメッセージ、あるいはメッセージを処理またはキューに登録した"
641	"時に通知するフィードバックが欲しいメッセージに対しては、メッセージの"
642	"クラス要求を使用してください。イベントを他のプロセスに通知するのみの"
643	"メッセージに対しては、クラス通知を使用してください。"
644	""
645	"    TT_NOTICE:  通知は、他のツールにイベントの発生を知らせる"
646	"                メッセージです。通知を送信するツールは、返信を"
647	"                期待しません。送信側は、何かが発生したことを"
648	"                他のツールに知らせるだけです。"
649	""
650	"    TT_REQUEST: 要求は、他のツールにアクションの実行を要求する"
651	"                メッセージです。要求ツールは、値が返されることを"
652	"                いつもではありませんが、しばしば期待しています。"
653	"                この値は、要求に対する返信として返されます。値が"
654	"                返されない場合でさえも、要求を処理するツールは、"
655	"                正常終了または異常終了を示す返信を送信します。"
656	"状態:"
657	"メッセージの状態属性の値。"
658	"可能な値とその意味を以下に示します。"
659	""
660	"    TT_CREATED:  メッセージを作成しましたが、まだ送信していません。"
661	"                 メッセージの送信側のみがこの状態のメッセージを見られます。"
662	""
663	"    TT_SENT:     メッセージを送信しましたが、まだ処理していません。"
664	""
665	"    TT_HANDLED:  メッセージを処理しました。戻り値は有効です。"
666	""
667	"    TT_FAILED:   メッセージをハンドラに配信できません。"
668	""
669	"    TT_QUEUED:   メッセージを後で配信するために、キューに登録しました。"
670	""
671	"    TT_STARTED:  このメッセージを処理するプロセスを開始中です。"
672	""
673	"    TT_REJECTED: 可能なハンドラが、メッセージを拒否しました。"
674	"                 この状態は、プロセスが拒否している時のみに見られます。"
675	"                 ToolTalk は状態を、別の可能なハンドラにメッセージを"
676	"                 発信する前に、TT_SENT に戻します。"
677	"処置:"
678	"実行中のプロセスが、どれもメッセージを処理できない場合に、実行するアク"
679	"ションを指定します。Handler_Ptype のプロセスをキューに登録するまで、メ"
680	"ッセージをキューに登録しなければならない場合には、キューに登録します。"
681	"Handler_Ptype のプロセスを起動しなければならない場合は、起動します。"
682	""
683	"    TT_QUEUE: 適切な ptype のプロセスがメッセージを受信するまで、"
684	"              メッセージをキューに登録します。"
685	""
686	"    TT_START: 何も実行中でない場合に、適切な ptype のプロセスを"
687	"               起動しようとします。"
688	""
689	"Tt_disposition 値は、1 つにまとめることができるので、"
690	"TT_QUEUE+TT_START は、メッセージをキューに登録することと、プロセスを"
691	"起動しようとすることの両方を指示することに注意してください。これは、"
692	"起動が失敗(またはユーザが拒否)できる場合に、適切なプロセスを起動した"
693	"直後にメッセージを処理することを保証できるので役立ちます。"
694	"送信側:"
695	"メッセージを送信したプロセスを識別します。"
696	"送信側 ptype:"
697	"メッセージを送信したプロセスの有効なユーザ識別子。"
698	"Args:"
699	"操作に固有の任意の引き数を入力してください。各引き数を順番に追加するには、"
700	"tt_message_arg_add を使用してください。各引き数には、モード(in、out、または inout)、"
701	"タイプ、およびモードが in または inout の場合には値を指定してください。"
702	"モード:"
703	"メッセージ引き数のモードを指定します。"
704	"可能な値と意味は以下のとおりです。"
705	""
706	"    TT_IN:    引き数は送信側によって書き込まれ、ハンドラおよび"
707	"              任意のオブザーバによって読み取られます。"
708	""
709	"    TT_OUT:   引き数はハンドラによって書き込まれ、送信側および"
710	"              任意の応答オブザーバによって読み取られます。"
711	""
712	"    TT_INOUT: 引き数は書き込まれ、送信側、ハンドラおよび任意の"
713	"              オブザーバによって読み取られます。"
714	"タイプ:"
715	"タイプを示す文字列。開発者が独自に作成できますが、共通の値は"
716	"\"string\" と \"int\" です。"
717	"値:"
718	"タイプに依存する実際のデータの値。"
719	"[追加] ボタン:"
720	"モード、タイプおよび値付きの引き数を追加します。"
721	"[削除] ボタン:"
722	"選択した引き数を削除します。"
723	"[変更] ボタン:"
724	"選択した引き数を、現在のモードの値とタイプの値に変更します。"
725	""
726	"[適用] ボタン:"
727	"このパターンに一致する受信メッセージを登録します。"
728	"名前:"
729	"このコンテキストの名前。"
730	"値:"
731	"タイプに適合する値。"
732	""
733	"すなわち、int タイプに 55、char タイプに \"fred\"、またはバイト・"
734	"タイプに ^V^L^X。"
735	"コンテキストの追加:"
736	"名前フィールドと値フィールドの現在の値をコンテキストのリストに"
737	"追加します。"
738	"コンテキストの削除:"
739	"選択したエントリをコンテキストのリストから削除します。"
740	"コンテキストの変更:"
741	"選択したエントリを、名前フィールドと値フィールドの内容に変更します。"
742	"送信コンテキストの編集:"
743	"送信したいコンテキストのリストを編集するウィンドウをポップアップします。"
744	"メッセージ"
745	"----------"
746	"メッセージを送信するには、まず新規メッセージを割り当て適切な情報を"
747	"入力した後で、送信してください。返信が同じメッセージ内に現れます。"
748	"メッセージが終了した時は、メッセージの記憶領域を開放してください。"
749	"(要求を返す値は、必要な戻り値をコピーした後に開放してください。"
750	"通知は、送信後直ちに開放してください。)"
751	""
752	"新規メッセージを割り当てるには、tt_message_create() を使用してくだ"
753	"さい。これは、\"ハンドル\" または \"隠されたポインタ\" をメッセージに返します。"
754	"このハンドルを続く呼び出しに使用して、このメッセージを参照してください。"
755	""
756	"メッセージ情報を記入するには tt_message_*_set() 呼び出しを使用して"
757	"ください。ここにメッセージの各属性の 1 つがあります。"
758	""
759	"クラス、アドレス、Op、および Args を設定してください。"
760	""
761	"tt_message_send() を用いてメッセージを送信してください。"
762	"アドレス:"
763	"ツールのタイプは多く、別のユーザは、別のツール・セット"
764	"を別の時に使用するので、メッセージの発信側にとって、"
765	"メッセージの受信側を正確に識別することは、しばしば"
766	"不可能です。代わりに、送信側はメッセージの意味を指定"
767	"する操作名を、メッセージの宛先のオブジェクトまたは"
768	"オブジェクト型(otype)に与えます。"
769	""
770	"オブジェクトまたはオブジェクト指向メッセージを使用してください。"
771	"アドレスがハンドラの場合には、ハンドラを指定してください。"
772	""
773	"    TT_PROCEDURE: Op および Args が指定されました。"
774	""
775	"    TT_OBJECT:    オブジェクト、Op、および Args が指定されました。"
776	""
777	"    TT_HANDLER:   ハンドラ、Op、および Args が指定されました。"
778	""
779	"    TT_OTYPE:     otype、Op、および Args が指定されました。"
780	"ハンドラ:"
781	"ハンドラの正確なプロセス ID がわかる場合は、メッセージをそこに"
782	"直接アドレスできます。通常の方法では、これは 1 つのプロセスに"
783	"対して一般的要求を行い、返信からハンドラ属性を取り出して、同じ"
784	"ハンドラに追加メッセージを送ります。これは 2 つのプロセスが、"
785	"渡される同報メッセージを介して出会い、対話に入ることを可能に"
786	"します。"
787	"Handler_Ptype:"
788	"メッセージを処理するプロセスの ptype が分かる場合には、それを"
789	"入力してください。プロトコルの詳細を理解するには、ptype 定義を"
790	"調べると、ptype がわかります。"
791	"オブジェクト:"
792	"メッセージを送信するオブジェクトの objid を入力してください。"
793	"OType:"
794	"オブジェクトの型"
795	"Op:"
796	"実行する通知または要求を記述する操作を入力してください。"
797	"操作名を決定するには、ターゲット・オブジェクトの otype 定義を"
798	"調べてください。"
799	"範囲:"
800	"同じセッションに他のプロセスからのメッセージがある場合には、プロセスの"
801	"必要に応じて、範囲セッションを使用してください。ファイルに関する"
802	"メッセージが必要な場合には、範囲ファイルを使用してください。"
803	""
804	"    TT_SESSION:          セッション内の他のプロセスからのメッセージを"
805	"                         受信します。"
806	""
807	"    TT_FILE:             結合したファイルに関するメッセージを受信します。"
808	""
809	"    TT_BOTH:             ファイルおよびセッションに関するメッセージを受信します。"
810	""
811	"    TT_FILE_IN_SESSION:  このセッションの中で結合したファイルに"
812	"                         関するメッセージを受信します。"
813	"セッション:"
814	"範囲セッションには、セッション(デフォルトでは tt_default_session())を"
815	"指定してください。"
816	"ファイル:"
817	"ファイル範囲には、ファイルの名前を指定してください。"
818	"クラス:"
819	"値を返すメッセージ、あるいはメッセージを処理またはキューに登録した"
820	"際に通知するフィードバックが欲しいメッセージには、クラス要求を使用"
821	"してください。他のイベントのプロセスを通知するだけのメッセージには、"
822	"クラス通知を使用してください。"
823	""
824	"    TT_NOTICE:  通知は、他のツールにイベントの発生を知らせる"
825	"                メッセージです。通知を送信するツールは、返信を"
826	"                期待しません。送信側は、何かが発生したことを"
827	"                他のツールに知らせるだけです。"
828	""
829	"    TT_REQUEST: 要求は、他のツールにアクションの実行を要求する"
830	"                メッセージです。要求ツールは、値が返されることを"
831	"                いつもではありませんが、しばしば期待しています。"
832	"                この値は、要求に対する返信として返されます。値が"
833	"                返されない場合でさえも、要求を処理するツールは、"
834	"                正常終了または異常終了を示す返信を送信します。"
835	"処置:"
836	"実行中のプロセスが、どれもメッセージを処理できない場合に、実行するアク"
837	"ションを指定します。Handler_Ptype のプロセスをキューに登録するまで、メ"
838	"ッセージをキューに登録しなければならない場合には、キューに登録します。"
839	"Handler_Ptype のプロセスを起動しなければならない場合は、起動します。"
840	""
841	"    TT_QUEUE: 適切な ptype のプロセスがメッセージを受信するまで、"
842	"              メッセージをキューに登録します。"
843	""
844	"    TT_START: 何も実行中でない場合に、適切な ptype のプロセスを"
845	"               起動しようとします。"
846	""
847	"Tt_disposition 値は、1 つにまとめることができるので、"
848	"TT_QUEUE+TT_START は、メッセージをキューに登録することと、プロセスを"
849	"起動しようとすることの両方を表すことに注意してください。これは、"
850	"起動が失敗(またはユーザが拒否)できる場合に、適切なプロセスを起動した"
851	"直後にメッセージを処理することを保証できるので役立ちます。"
852	"Sender_Ptype:"
853	"メッセージを送信するプロセスの ptype。"
854	"ステータス"
855	"応答側が返すメッセージの結果を示す一意の番号。"
856	"この番号は TT_ERR_LAST (2047) よりも大きくなければなりません。"
857	"ステータス文字列:"
858	"メッセージのステータスのテキスト説明。"
859	"Args:"
860	"操作に固有の任意の引き数を入力してください。各引き数を順番に追加"
861	"するには、tt_message_arg_add を使用してください。各引き数には、"
862	"モード(in、out、または inout)、タイプ、およびモードが in または"
863	"inout の場合には値を指定しなければなりません。"
864	"モード:"
865	"メッセージ引き数のモードを指定します。可能な値とその意味は、以下の"
866	"とおりです:"
867	""
868	"    TT_IN:    引き数は送信側によって書き込まれ、ハンドラおよび"
869	"              任意のオブザーバによって読み取られます。"
870	""
871	"    TT_OUT:   引き数はハンドラによって書き込まれ、送信側および"
872	"              任意の応答オブザーバによって読み取られます。"
873	""
874	"    TT_INOUT: 引き数は書き込まれ、送信側、ハンドラおよび任意の"
875	"              オブザーバによって読み取られます。"
876	"タイプ:"
877	"タイプを示す文字列。開発者が独自に作成できますが、共通の値は"
878	"\"string\" と \"int\" です。"
879	"値:"
880	"タイプに依存する実際のデータの値。"
881	"[追加] ボタン:"
882	"モード、タイプおよび値付きの引き数を追加します。"
883	"[削除] ボタン:"
884	"選択した引き数を削除します。"
885	"[変更] ボタン:"
886	"選択した引き数を、現在のモード、タイプ、および値に"
887	"変更します。"
888	"[送信] ボタン:"
889	"このメッセージを送信します。また、このメッセージを作成および送信"
890	"するのに ToolTalk が行った呼び出しを標準出力に出力します。"
891	"名前:"
892	"このコンテキストの名前。"
893	"値:"
894	"タイプとして解釈されるこのコンテキストの値。"
895	"追加:"
896	"テキスト・フィールドに新規コンテキストとして値を追加します。"
897	"削除:"
898	"現在の選択コンテキストを削除します。"
899	"変更:"
900	"選択したコンテキストを変更し、現在テキスト・フィールドにある内容を"
901	"反映します。"
902	"出力のパイプを開くことができません。\n"
903	"Tts_string_list: 生成がメッセージを呼び出しました。無視します。\n"
$set 11
2	"TT_OK\t要求が正常終了しました。"
3	"TT_WRN_NOTFOUND\tオブジェクトが見つからないので、削除できませんでした。"
4	"TT_WRN_STALE_OBJID\tメッセージのオブジェクト属性が新しいものに置換されました。獲得したオブジェクト ID の元のものを更新してください。"
5	"TT_WRN_STOPPED\tフィルタ・プロシージャが照会を停止しました。"
6	"TT_WRN_SAME_OBJID\t移動したオブジェクトは同じオブジェクト ID を保持しています。"
7	"TT_WRN_START_MESSAGE\tメッセージがプロセスを起動します。このメッセージが通知の場合でも、返信が必要です。"
8	"TT_WRN_APPFIRST\tこのコードを使用してはいけません。"
9	"TT_WRN_LAST\tこのコードを使用してはいけません。"
10	"TT_ERR_CLASS\t渡された Tt_class 値が無効です。"
11	"TT_ERR_DBAVAIL\t必須データベースが使用できません。一時的なものだと思われますので、後で再試行してください。"
12	"TT_ERR_DBEXIST\t必須データベースが存在しません。このアクションを行う前に、データベースが作成されていなければなりません。"
13	"TT_ERR_FILE\tファイル・オブジェクトが見つかりません。"
14	"TT_ERR_MODE\tTt_mode 値が無効です。"
15	"TT_ERR_ACCESS\tToolTalk オブジェクトへのアクセスは、保護システムによって禁止されています。"
16	"TT_ERR_NOMP\tttsession プロセスが動作していません。多分、tt_open() が呼び出されていないことが原因です。tt_open() からこのコードが返された場合は、ttsession が起動できないという意味であり、通常は ToolTalk がこのシステムにインストールされていません。"
17	"TT_ERR_NOTHANDLER\tメッセージのハンドラだけがこれを実行できます。"
18	"TT_ERR_NUM\t渡された整数値が有効ではありません。"
19	"TT_ERR_OBJID\t渡されたオブジェクト ID が既存オブジェクト仕様に即していません。"
20	"TT_ERR_OP\t渡された操作名が構文的に有効ではありません。"
21	"TT_ERR_OTYPE\t渡されたオブジェクトが、インストールされたオブジェクト型の名前ではありません。"
22	"TT_ERR_ADDRESS\t渡された Tt_address 値は有効ではありません。"
23	"TT_ERR_PATH\t渡されたファイル・パスのディレクトリの 1 つが存在しないか、読めません。"
24	"TT_ERR_POINTER\t渡された隠されたポインタ(ハンドル)は、適切な型のオブジェクトを示しません。"
25	"TT_ERR_PROCID\t渡されたプロセス ID は有効ではありません。"
26	"TT_ERR_PROPLEN\t渡された属性値が長すぎます。"
27	"TT_ERR_PROPNAME\t渡された属性名は構文的に有効ではありません。"
28	"TT_ERR_PTYPE\t渡されたプロセス・タイプはインストールされたプロセス・タイプの名前ではありません。"
29	"TT_ERR_DISPOSITION\t渡された Tt_disposition 値は有効ではありません。"
30	"TT_ERR_SCOPE\t渡された Tt_scope 値は有効ではありません。"
31	"TT_ERR_SESSION\t渡されたセッション ID はアクティブ・セッションの名前ではありません。"
32	"TT_ERR_VTYPE\t渡された値タイプ名は有効ではありません。"
33	"TT_ERR_NO_VALUE\t指定された名前と番号の属性値は存在しません。"
34	"TT_ERR_INTERNAL\t内部エラー(バグ)"
35	"TT_ERR_READONLY\t属性を変更できません。"
36	"TT_ERR_NO_MATCH\tこのメッセージを見つけられるハンドラはありません。後処理をキューに登録または開始できません。"
37	"TT_ERR_UNIMP\t機能は提供されていません。"
38	"TT_ERR_OVERFLOW\tアクティブ・メッセージが多すぎます(後でもう一度試してください)。"
39	"TT_ERR_PTYPE_START\tptype のインスタンスの起動に失敗しました。"
40	"TT_ERR_CATEGORY\tパターン・オブジェクトにカテゴリが設定されていません。"
41	"TT_ERR_DBUPDATE\tデータベースに一貫性がありません: 最初に他の tt_spec_write がオブジェクトを更新しました。"
42	"TT_ERR_DBFULL\tTooltalk データベースがフルです。"
43	"TT_ERR_DBCONSIST\tデータベースが壊れているか、アクセス情報が不完全です。(ttdbck を実行してください。)"
44	"TT_ERR_STATE\tTt_message が意図した操作には無効な Tt_state にあります。"
45	"TT_ERR_NOMEM\tこれ以上メモリを使用できません"
46	"TT_ERR_SLOTNAME\tスロット名が構文的に無効です。"
47	"TT_ERR_XDR\t渡された XDR proc. が 0 len と判断されたか、起動時に異常終了しました。"
48	"TT_ERR_NETFILE\t渡された netfilename は構文的に無効です。"
49	"TT_DESKTOP_UNMODIFIED\t操作は無変更のエンティティには適用されません。"
50	"TT_MEDIA_ERR_SIZE\t指定したサイズが大きすぎるか、小さすぎます。"
51	"TT_MEDIA_ERR_FORMAT\tデータがその形式に適合していません。"
52	"TT_ERR_APPFIRST\tこのコードを使用してはいけません。"
53	"TT_ERR_LAST\tこのコードを使用してはいけません。"
54	"TT_STATUS_LAST\tこのコードを使用してはいけません。"
55	"未知の Tt_status 値"
56	"TT_DESKTOP_EPERM\tスーパーユーザではありません。"
57	"TT_DESKTOP_ENOENT\t指定されたファイルまたはディレクトリがありません。"
58	"TT_DESKTOP_EINTR\tシステム・コールが中断されました。"
59	"TT_DESKTOP_EIO\tI/O エラーです。"
60	"TT_DESKTOP_EAGAIN\tこれ以上プロセスを処理できません。"
61	"TT_DESKTOP_ENOMEM\t十分な空き領域がありません。"
62	"TT_DESKTOP_EACCES\tアクセス権が拒否されました。"
63	"TT_DESKTOP_EFAULT\tアドレスが不正です。"
64	"TT_DESKTOP_EEXIST\tファイルが存在します。"
65	"TT_DESKTOP_ENODEV\t指定されたデバイスはありません。"
66	"TT_DESKTOP_ENOTDIR\tディレクトリではありません。"
67	"TT_DESKTOP_EISDIR\tディレクトリです。"
68	"TT_DESKTOP_EINVAL\t引き数が無効です。"
69	"TT_DESKTOP_ENFILE\tファイル・テーブルがオーバーフローしました。"
70	"TT_DESKTOP_EMFILE\t開くファイルが多すぎます。"
71	"TT_DESKTOP_ETXTBSY\tテキスト・ファイルは使用中です。"
72	"TT_DESKTOP_EFBIG\tファイルが大きすぎます。"
73	"TT_DESKTOP_ENOSPC\tデバイスに空き領域が残っていません。"
74	"TT_DESKTOP_EROFS\t読み込み専用のファイル・システムです。"
75	"TT_DESKTOP_EMLINK\tリンクが多すぎます。"
76	"TT_DESKTOP_EPIPE\tパイプが壊れています。"
77	"TT_DESKTOP_ENOMSG\t必要な型のメッセージがありません。"
78	"TT_DESKTOP_EDEADLK\tデッドロック状態です。"
79	"TT_DESKTOP_ENODATA\t使用可能なデータがありません。"
80	"TT_DESKTOP_EPROTO\tプロトコル・エラーです。"
81	"TT_DESKTOP_ENOTEMPTY\tディレクトリが空ではありません。"
82	"TT_DESKTOP_ETIMEDOUT\t接続がタイムアウトしました。"
83	"TT_DESKTOP_EALREADY\t操作は、すでに実行中です。"
84	"TT_DESKTOP_ECANCELED\t操作を取り消しました。"
85	"TT_DESKTOP_ENOTSUP\tサポートされていません。"
86	"TT_ERR_TOOLATE\tThis must be the first call made into the ToolTalk API and can therefore no longer be performed."
87	"TT_ERR_AUTHORIZATION\tThe user is not authorized to connect to this ToolTalk session."
88	"TT_AUTHFILE_ACCESS\tThe user is not authorized to access the ToolTalk authority file."
89	"TT_AUTHFILE_LOCK\tCannot lock the ToolTalk authority file."
90	"TT_AUTHFILE_LOCK_TIMEOUT\tCannot lock the ToolTalk authority file."
91	"TT_AUTHFILE_UNLOCK\tCannot unlock the ToolTalk authority file."
92	"TT_AUTHFILE_MISSING\tThe ToolTalk authority file is missing."
93	"TT_AUTHFILE_ENTRY_MISSING\tThe ToolTalk authority file is missing an entry for this session."
94	"TT_AUTHFILE_WRITE\tCannot write the ToolTalk authority file."
95	"TT_ERR_VERSION_MISMATCH\tThis client is using a different RPC or program version from the server of this ToolTalk session."
