$ $XConsortium: SUNW_TOOLTALK.msg /main/3 1996/07/24 19:02:24 drk $
$quote "
$set 1
3	"在 %s 的 rpc.ttdbserverd 的 clnt_create 失敗%s"
4	"'錯誤：在 %s 的 rpc.ttdbserverd 沒有執行"
6	"伺服器版本 (%s) 與資料庫表版本 (%s) 不符。\請執行版本號碼為 %s 的資料庫伺服器"
7	"嘗試開啟資料庫表 %s：%s 失敗"
14	"無法刪除 X 根視窗特性 %s 公告此階段\作業"
15	"位址版本為 %d，但我只認得 %d! (位址：<%s>)"
17	"無法解析 X 顯示器名稱：\"%s\""
18	"檔案 \"%s\" 的訊息無法佇列，因為發生內部錯誤 %\d"
19	"無法刪除未作用的階段作業 <%s> 從檔案 \"%s\" 的權益列表中，因為發生內部錯誤 %d"
20	"無法刪除未登記權益的階段作業 <%s> 從檔案 \"%s\" 的權益列表中，因為發生內部錯誤 %d"
21	"tttracefile 語法錯誤行號：\n%s"
22	"無法處理在 $%s 的 tttracefile"
23	"如果真正的 UID 不等於有效的 UID，則不允許追蹤"
24	"接受要求"
25	"空白文件且無檔案"
26	"無法獲得 messageID；此操作也許無法取消，因為 tt_m\essage_arg_val()"
27	"無法取得標題；文件將沒有標題，因為 tt_message_arg_v\al()"
28	"不明的 opnum 偏移"
$set 2
2	"ptype %s - 發現無法辨識的類別記號"
3	"沒有連接導向的運送"
4	"一個 ToolTalk 客戶機在可以被通知取回它到期的訊息之前，便已經當機了"
5	"在通知 ToolTalk 客戶機可以 \取回一個訊息時，連接中斷"
6	"另一個階段作業正在執行 (主機=%s, pid=%d)"
7	"無法連絡原先宣告的階段作業 (主機=%s, pid=%d)；因此假設它已當機..."
8	"無法解析公告的階段作業 id；因此以我自己的 id 重寫..."
9	"%s 是一個 version %d 類型的資料庫，這一版只能讀取 versions %d 以及更早的版本"
10	"類型資料庫：%s 中的類型無法解碼。也許是已損毀。"
11	"重寫 %s"
12	"忽略 ToolTalk 類別記號的不明屬性 <%s>..."
13	"ttce2xdr 失敗；(狀態=%d)；Classing Engine \"使用者\" 資料庫中的類別沒有轉換..."
14	"複製 ISAM 記錄"
15	"ISAM 檔案未開啟"
16	"ISAM 引數不合法"
17	"ISAM 鍵描述元不合法"
18	"開啟太多 ISAM 檔案"
19	"ISAM 檔案格式錯誤"
20	"ISAM 非專用存取"
21	"ISAM 記錄被鎖定"
22	"ISAM 鍵已存在"
23	"ISAM 鍵是主鍵"
24	"ISAM 檔案開始或結束"
25	"無法找到 ISAM 記錄"
26	"沒有現行的 ISAM 記錄"
27	"ISAM 檔案被鎖定"
28	"ISAM 檔名太長"
29	"ISAM 無法配置記憶體"
30	"ISAM RPC 逾時"
31	"ISAM TCP/IP 連接中斷"
32	"無法連接 ISAM 伺服器"
33	"無法轉取 ISAM 資料"
34	"沒有本端 SAM 精靈程式"
35	"ISAM 發生內部嚴重錯誤"
36	"ISAM Locale/LANG 不符"
$set 3
2	"子節點 (%d) 結束，原因為訊號 %d%s"
3	" (核心轉存)"
4	"子節點 (%d) 既未結束，也沒有接收到訊號!"
5	"無法將客戶機放至最大，因為 %m"
6	"沒有範圍可以管理。請使用 -c, -p, -d, 或設定 $DISPLAY。"
7	"-S 選項無法和 -c 搭配使用"
8	"子 ttsession 結束，狀態為 %d"
9	"子 ttsession 結束，原因為訊號 %d%s"
10	"(核心轉存)"
11	"子 ttsession 既未結束，也未接收到訊號!"
12	"啟動中"
13	"有尚未讀取的類型"
14	"類型有誤；保留舊的類型"
15	"$OPENWINHOME 未設定"
16	"\n用法：ttsession [-a unix|des][-d display][-spStvhNX"
17	"][-c command]\n -c [command]	啟動一個處理樹階段作業，然後在其中執行命令。\n		後續的選項會傳遞給命令。內定值：$SHELL\n -p		啟動一個處理樹階段作業，然後列印其 id\n -d display	在顯示器上啟動一個 X 階段作業\n\n -a unix|des	設定伺服器確定層次\n -s		關閉警告，不列印任何警告\n -S		不產生子程序到背景\n -N		將允許的客戶機數目設定到最大\n -t		開啟訊息追蹤功能\n -X		使用 XDR 資料庫作為靜態類型 (內定值)\n"
18	" -E		使用 Classing Engine 作為靜態類型\n"
19	"\n -v		列印版本號碼\n -h		列印這則訊息\n\
\n訊號介面：\n kill -USR1 ttsession_pid	切換訊息追蹤功能\n kill -USR2 ttsession_pid	重新讀取靜態類型"
20	"結束"
$set 4
2	"用法：\ntt_type_comp [-s] [-d db] [-mM] source_file\ntt_type_comp [-s\
] [-d db] -r type ...\n-M	將來源類型合併到指定的資料庫，不更新\
現存的類型\n-m	合併，但更新現存類型。\
為內定值。\n-r	從指定的資料庫中除去來源類型\n-d db  要操作的資料庫。\
可能為使用者、系統或網路之一。內定值：使用者\n-G	在 ToolTalk 資料庫伺服器執行垃圾收集.\n\ntt_type_comp [-sE] -p|O|P [-d db]\ntt_type_comp [-s\
]  -p|O|P compiled_file\n-O	在 stdout 上列出讀入的\
所有 otypes 的名稱\n-P	在 stdout 上列出讀入的\
所有 ptypes 的名稱\n\\n-p	以較美觀的版面在 stdout 上\
印出讀入的所有 ToolTalk 類型\n-E	使用 Classing Engine 資\
料庫取代 XDR 資料庫\n-d db	要讀取的資料庫。可能為使用者、系\
統或網路之一。內定值：全部\n\ntt_type_comp [-s] -x [-o \
compiled_file] source_file\n-x	編譯來自 source_file \
(或 stdin，如果檔案是 \"-\") 的類型\n-o	將已編譯的類型\
寫到 compiled_file (或 stdout，如果檔案是 \"-\")\n	內定值：\
source_file.xdr，或 \"types.xdr\"，如果來源是\
 stdin\n\ntt_type_comp [-hv]\n-v	印出版本號碼\n-h	印出這則\
訊息\n-s	不印出任何狀態訊息。\n\n這些 cpp 選項的傳遞將\
透過：\n	  -undef -Dname -Idirectory -Uname -Ydirectory"
3	"類型檔案語意有誤"
4	"不是有效的 ToolTalk 類型檔案"
5	"無法從 Classing Engine 資料庫讀取任何 ToolTalk 類型"
6	"合併 Classing Engine 表的功能已不再提供"
7	"無法在 %s 資料庫讀取類型 - 版本不符"
8	"無法在 %s 資料庫讀取類型"
9	"$OPENWINHOME 未設定"
10	"無法起始設定 %s 資料庫以寫入"
11	"無法除去 %s 的舊定義"
12	"重寫中"
13	"寫入中"
14	"%s 無法增加新定義"
15	"無法除去 %s 的舊定義"
16	"重寫"
17	"寫入"
18	"%s 無法增加新定義"
19	"編譯的類型版本不符"
20	"無法讀取資料庫中的類型"
21	"$OPENWINHOME 未設定"
22	"無法在 %s 資料庫讀取類型 - 版本不符"
23	"無法在 %s 資料庫讀取類型"
24	"$OPENWINHOME 未設定"
25	"除去 otype %s 中\n"
26	"除去 ptype %s 中\n"
27	"輸出寫到 %s\n"
28	"無效的資料庫：%s"
29	"請只指定下列選項之一 -O -P -m -M -p -r -x"
30	"未進行前處理，原因：%s：%s"
31	"otype 繼承週期包含 %s"
32	"otype %2$s 的祖先節點 %1$s 不存在"
33	"ptype %s 不存在，但已被 otype %s 取名作為製作者"
34	"otype %s 中定義了多重的處理器"
35	"otype %s 中所繼承的類別記號在母節點中不存在"
36	"兩個 ptypes，%s 與 %s，具有相同的處理器"
37	"otype %2$s 的祖先節點 %1$s 不存在"
38	"循環 otype 繼承階層 -\n  {"
39	"otype %s 有重複的定義"
40	"ptype %s 有重複的定義"
$set 5
3	"違反安全性：RPC 呼叫要我開啟一個不是 ToolTalk 資料庫的檔案"
4	"在使用新的 rpc.ttdbserverd  (>= 1.1) 之後，任何使用舊的 (<= 1.0.2) rpc.ttdbserverd 所寫的資料都會被忽略"
5	"在使用新的 rpc.ttdbserverd  (>= 1.1) 之後，任何使用舊的 (<= 1.0.2) rpc.ttdbserverd 所寫的資料都會被忽略"
6	"rpc.ttdbserverd 版本 (%s) 與資料庫表版本 (%s) 不符。請安裝 rpc.ttdbserverd 版本 %s (或更新的版本)"
7	"用法：\nrpc.ttdbserverd [-S] [-n] [-m DTMOUNTPOINT]\nrpc.ttdbserverd [-S] [-v]"
8	"無法開啟垃圾收集處理. thr_create()\n"
9	"無法 fork() 垃圾收集.\n"
$set 6
2	"用法：\nttdbck [-f file] [-k objkey] [-t type] [-bx] \n[-impa] [-IZ] [-F newfilename] [-T newtype] [mountpoints]\n"
3	"ttdbck：如果指定了修護 [-FTZ] 選項，就必須指定一個選擇 [-fkt] 選項\n或診斷 [-bx] 選項\n"
4	"編譯類型的版本不符"
5	"無法讀取資料庫內的類型"
6	"ttdbck：請嘗試使用 'ttdbck -I'。\n"
7	"以檔名選取：%s\n"
8	"以 objid 鍵選取："
9	"以類型選取：%s\n"
10	"診斷到形成時有問題的實體\n"
11	"診斷參照到不存在的實體\n"
12	"顯示 ids\n"
13	"顯示必要的資料\n"
14	"顯示特性與數值資料\n"
15	"在檢查之前，先調用 NetISAM isrepair() 函數\n"
16	"要修護請設定成類型：%s\n"
17	"利用刪除修護\n"
18	"除錯列印輸出階層 %d\n"
19	"要修護請設定成檔案：%s\n"
20	"錯誤：沒有規格檔案。\n"
21	"錯誤：沒有規格類型。\n"
22	"錯誤：\"%s\" 不是一個已安裝的 otype。\n"
23	"錯誤：規格的類型特性有多個值。\n"
24	"錯誤："
25	"ttdbck：未找到錯誤。\n"
26	"錯誤："
$set 7
2	"用法：%s {ctx}[fhpPv[v]] [tarfile] pathname ...\n	 %s {ctx}fL[hpPRv[v]] tttarfile pathname ...\n	 %s -v\n	 %s -h\n"
3	"\tc	 建立一個文件保管\n\tt	 列示文件保管的內容\n\tx	 從文件保管中節錄\n\tf	 使用下一個引數 <tarfile> 作為文件保管\n\th	 遵循象徵性連結\n\tL	 不調用 tar(1)\n\tp	 保留檔案模態\n\tP	 (根) 不保留物件的所有者、修改時間等等。\n\tR	 不遞迴到目錄\n\tv	 使用冗長形式\n\tvv	使用特別冗長的形式\n\t-v	列印版本號碼後離開\n\t-h[elp] 列印這則訊息\n"
4	"%s：無法從文件保存串流中讀取物件種類。\n"
5	"%s：無法從文件保存串流中讀取文件保存版本。\n"
6	"%s：找到文件保存版本 %d，但需要的是版本 %d。\n"
7	"%s：在文件保存中找到不明類型 %d 的物件。\n"
8	"%s：無法從文件保存串流中讀取物件種類。\n"
9	"%s：無法從文件保存串流中讀取文件保存版本。\n"
10	"%s：找到文件保存版本 %d，但需要的是版本 %d。\n"
11	"%s：在文件保存中找到不明類型 %d 的物件。\n"
$set 8
2	"%s：無法除去 ToolTalk 物件 %s，因為 %s\n"
3	"%s：無法將 ToolTalk 物件從 \"%s\" 移到 \"%s\"，因為 %s\n"
4	"%s：將不會嘗試移動 ToolTalk 物件：\n"
5	"用法：%s [-] [-fL] path1 path2\n	 %s [-] [-fL] path1 [path2 ...] dir\n	 %s -v\n	 %s -h\n"
6	"\t-L	不執行 mv(1)\n\t-v	列印版本號碼然後離開\n\t-h	列印這則訊息\n"
7	"%s：無法除去 ToolTalk 物件 %s，因為 %s\n"
8	"用法：%s [-] [-%s] %s ...\n	 %s -v\n	 %s -h\n"
9	"檔案"
10	"目錄"
11	"\t-L	不執行 %s(1)\n\t-v	列印版本號碼然後離開\n\t-h[elp] 列印這則訊息\n"
12	"%s：無法除去 ToolTalk 物件 %s，因為 %s\n"
13	"用法：%s [-pL] file1 file2\n	 %s [-prRL] path1 [path2 ...] dir\n	 %s -v\n	 %s -h\n"
14	"\t-L	不執行 cp(1)\n\t-v	列印版本號碼然後離開\n\t-h	列印這則訊息\n"
$set 9
2	"用法：%s [-0FCa][-o outfile] [-S session | command [\
options]]\n	 %s [-e script | -f scriptfile][-S session | \
command [options]]\n -0		關閉階段作業中的訊息追蹤功能，或\
在沒有訊息追蹤\n		(即僅有 API 追蹤) 的情況下執行命令\n -F\
		遵循所有由命令產生的子程序的子節點，或\n	\
	在階段作業中由 ttsession(1) 接續啟動\n -C		不追蹤 \
ToolTalk API 呼叫\n -a		列印追蹤到的訊息的所有屬性、引數\
與\n		上下文插槽。內定值為單行摘要。\n -e script	讀取命\
令集中的 tttracefile(4) 設定\n -f scriptfile	從命令集檔案中讀取 \
tttracefile(4) 設定。\"-\"：stdin。\n -o outfile	輸出。\"-\"：\
stdout。內定值：階段作業追蹤為 stdout，\n		命令追蹤為 \
(tttrace 的) stderr\n -S session	要追蹤的階段作業。內定值：請參閱 \
tt_default_session()\n command	要調用與追蹤的 ToolTalk 客戶機命令\n"
3	"%s：階段作業 <%s> 不支援 Session_Trace。請改用 kill -USR1。請參閱 ttsession(1)。\n"
$set 10
2	"忽略傳遞給 Tts_address 的不明 Tt_address ::add()\n"
3	"忽略傳遞給 Tts_address 的不明 Tt_address ::remove()\n"
4	"忽略傳遞給 tts_address 的不明 address ::tts_set()\n"
5	"忽略傳遞給 tts_address 的不明 address ::tts_unset()\n"
6	"忽略 tts_address 所讀取的不明位址::load()\n"
7	"Tts_arglist::Tts_arglist - 讀取引數錯誤 - \n\t"
8	"Tts_arglist::載入 - 遇到不明的引數類型 - 使用 BARG\n"
9	"抽象的分類 Tts_arg::指定 (Tt_pattern) 呼叫 - 忽略\n"
10	"抽象的分類 Tts_arg::指定 (Tt_message) 呼叫 - 忽略\n"
11	"抽象的分類 Tts_arg::產生呼叫 - 忽略\n"
12	"抽象的分類 Tts_arg::儲存呼叫 - 忽略\n"
13	"抽象的分類 Tts_arg::載入呼叫 - 忽略\n"
14	"Tts_arg::mode_to_chars 無效的模態 - 使用 TT_INOUT\n"
15	"Tts_arg::chars_to_mode 無效的模態 - 使用 TT_INOUT\n"
16	"忽略傳遞給 Tts_category 的不明 Tt_category ::set()\n"
17	"Tts_category::generate() 呼叫訊息 - 忽略\n"
18	"忽略 tts_category 所讀取的不明種類::load()\n"
19	"忽略傳遞給 Tts_class 的不明 Tt_class::add()\n"
20	"忽略傳遞給 Tts_class 的不明 Tt_class::remove()\n"
21	"忽略傳遞給 tts_class 的不明種類::tts_set()\n"
22	"忽略傳遞給 tts_class 的不明種類::tts_unset()\n"
23	"忽略 tts_class 所讀取的不明種類::load()\n"
24	"Tts_connection::universal_callback - 此字串沒有字串鑄造功能!\n"
25	"Tts_cntxtlist::Tts_cntxtlist - 讀取上下文錯誤 - \n\t"
26	"Tts_contextlist::載入 - 遇到不明的 cntxt 類型 - 使用 BCNTXT\n"
27	"抽象的種類 Tts_context::指定 (Tt_pattern) 呼叫 - 忽略\n"
28	"抽象的種類 Tts_context::指定 (Tt_pattern) 呼叫 - 忽略\n"
29	"抽象的種類 Tts_context::產生呼叫 - 忽略\n"
30	"抽象的種類 Tts_context::儲存呼叫 - 忽略\n"
31	"抽象的種類 Tts_context::載入呼叫 - 忽略\n"
32	"忽略傳遞給 Tts_disposition 的不明 Tt_disposition::add()\n"
33	"忽略傳遞給 Tts_disposition 的不明 Tt_disposition::remove()\n"
34	"忽略傳遞給 tts_disposition 的不明處分::tts_set()\n"
35	"忽略傳遞給 tts_disposition 的不明處分::tts_unset()\n"
36	"忽略由 tts_disposition 讀取的不明處分::load()\n"
37	"呼叫 %s\n"
38	"ToolTalk 錯誤：%s\n	  起源：來源檔案 %s 第 %d 行\n"
39	"警告：%s\n	  起源：來源檔案 %s 第 %d 行\n"
40	" Tts_message_molding::send - 嘗試送出未起始設定的訊息鑄造\n"
41	"忽略傳遞給Tts_scope 的不明 Tt_scope::add()\n"
42	"忽略傳遞給 Tts_scope 的不明 Tt_scope::remove()\n"
43	"忽略傳遞給 tts_scope 的不明範圍::tts_set()\n"
44	"忽略傳遞給 tts_scope 的不明範圍::tts_unset()\n"
45	"忽略 tts_scope 所讀取的不明範圍::load()\n"
46	"忽略傳遞給 Tts_state 的不明 Tt_state::add()\n"
47	"忽略傳遞給 Tts_state 的不明 Tt_state::remove()\n"
48	"忽略傳遞給 tts_state 的不明狀態::tts_set()\n"
49	"忽略傳遞給 tts_state 的不明狀態::tts_unset()\n"
50	"Tts_state::generate() 呼叫訊息 - 忽略\n"
51	"忽略 tts_state 所讀取的不明狀態::load()\n"
82	"獲取 TTSnoop 輔助說明"
83	"----------------------"
84	"要得到一般 TTSnoop 輔助說明，請按「關於 TTSnoop」"
85	"按鈕。如需各別按鈕的輔助說明與設定，請將滑鼠置於"
86	"該按鈕 (或您有興趣的設定) 上方，然後按一下輔助說明"
87	"鍵。要知道 ttsnoop 目前所使用的 API 呼叫，請在調用"
88	"ttsnoop 時，加上 -t 參數。"
89	"使用 TTSnoop"
90	"-------------"
91	"要觀察訊息，請選取「啟動」這個設定選擇。"
92	""
93	"要關閉訊息觀察，請選取「停止」這個設定選擇。"
94	""
95	"要限定訊息的類型："
96	"	1) 選取「字串」按鈕"
97	"	2) 輸入您想觀察的字串類型"
98	"	3) 選取「應用」按鈕"
99	""
100	"要以高亮度表示顯示的資訊："
101	"	1) 選取「顯示」按鈕"
102	"	2) 標註您想以高亮度表示的項目"
103	"	3) 選取「應用」按鈕"
104	""
105	"要送出訊息："
106	"	1) 選取「訊息」按鈕"
107	"	2) 撰寫訊息"
108	"	3) 選取「送出訊息」按鈕"
109	""
110	"要儲存訊息："
111	"	1) 選取「訊息」按鈕"
112	"	2) 撰寫訊息"
113	"	3) 選取「增加訊息」按鈕"
114	""
115	"要送出一個事先存好的訊息："
116	"	從「送出訊息」功能表中選取訊息"
117	""
118	"要清除訊息輸出視窗，請選取「清除」按鈕。"
119	""
120	"ToolTalk 一般資訊"
121	"----------------------------"
122	"在透過 ToolTalk 送出或接收物件導向"
123	"的訊息之前，要先向訊息傳遞器註冊"
124	"一個處理。註冊可讓這個處理告知"
125	"ToolTalk 許多訊息："
126	""
127	"      這個處理的處理類型 (ptype)。"
128	"      這可讓訊息傳遞器將由此"
129	"      所製作的訊息引導到此處"
130	"      理。"
131	""
132	"      這個處理所在的階段作業。"
133	""
134	"      這個處理正在觀察的文件。如此，"
135	"      傳遞給這些文件中物件的訊息，就"
136	"      可以發送到這個處理中。"
137	""
138	""
139	"注意，這些註冊動作一般會修改產生的字"
140	"串。您可以使用字串操控 API 呼叫來觀察"
141	"或處理物件導向的訊息，但此處描述的方"
142	"法要短得多，因為它們利用到了在類型定"
143	"義中所宣告的資訊。"
144	""
145	""
146	""
147	"使用 tt_session_join 以便加入作為階段作業的一部分。"
148	"加入時，您必須提供要加入的階段作業的"
149	"階段作業 id。"
150	""
151	"當您的工具不再需要 ToolTalk 服務時，"
152	"請利用 tt_session_quit 結束階段作業。"
153	""
154	"當您的工具載入一個檔案，它必須利用"
155	"呼叫 tt_file_join() 的方式，加入登記權益"
156	"於該檔案的處理群組中；檔案處理完成"
157	"之後，請呼叫 tt_file_quit() 離開這些處理。"
158	"有些工具會一次開啟數個檔案；有些則"
159	"一次只開啟一個檔案。"
160	"使用 TTSnoop"
161	"-------------"
162	"要觀察訊息，請選取「啟動」這個設定選擇。"
163	"要關閉訊息觀察，請選取「停止」這個設定選擇。"
164	""
165	"要限定訊息的類型："
166	"        1) 選取「字串」按鈕"
167	"        2) 輸入您想觀察的字串類型"
168	"        3) 選取「應用」按鈕"
169	""
170	"要以高亮度表示顯示的資訊："
171	"        1) 選取「顯示」按鈕"
172	"        2) 標註您想以高亮度表示的項目"
173	"        3) 選取「應用」按鈕"
174	""
175	"要送出訊息："
176	"        1) 選取「訊息」按鈕"
177	"        2) 撰寫訊息"
178	"        3) 選取「送出訊息」按鈕"
179	""
180	"要儲存訊息："
181	"        1) 選取「訊息」按鈕"
182	"        2) 撰寫訊息"
183	"        3) 選取「增加訊息」按鈕"
184	""
185	"要送出一個事先存好的訊息："
186	"        從「送出訊息」功能表中選取訊息"
187	""
188	"要清除訊息輸出視窗，請選取「清除」按鈕。"
189	""
190	"ToolTalk 一般資訊"
191	"----------------------------"
192	"在透過 ToolTalk 送出或接收物件導向"
193	"的訊息之前，要先向訊息傳遞器註冊"
194	"一個處理。註冊可讓這個處理告知"
195	"ToolTalk 許多訊息："
196	"        這個處理的處理類型 (ptype)。"
197	"        這可讓訊息傳遞器將由此所製"
198	"        作的訊息引導到此處理。"
199	""
200	"        這個處理所在的階段作業。"
201	""
202	"        這個處理正在觀察的文件。如此，"
203	"        傳遞給這些文件中物件的訊息，就"
204	"        可以發送到這個處理中。"
205	""
206	"注意，這些註冊動作一般會修改產生的字"
207	"串。您可以使用字串操控 API 呼叫來觀察"
208	"或處理物件導向的訊息，但此處描述的方"
209	"法要短得多，因為它們利用到了在類型定"
210	"義中所宣告的資訊。"
211	""
212	"使用 tt_session_join 以便加入作為階段作業的一部分。加入時，"
213	"您必須提供要加入的階段作業的階段作業 id。"
214	""
215	"當您的工具不再需要 ToolTalk 服務時，"
216	"請利用 tt_session_quit 結束階段作業。"
217	""
218	"當您的工具載入一個檔案，它必須利用呼叫 tt_file_join()"
219	"的方式，加入登記權益於該檔案的處理群組中；檔案"
220	"處理完成之後，請呼叫 tt_file_quit() 離開這些處理。"
221	"有些工具會一次開啟數個檔案；有些則一次只開啟"
222	"一個檔案。"
223	"啟動/停止接收與顯示訊息。"
224	"清除訊息視窗。"
225	"顯示"
226	"-------"
227	"當一個訊息到達您的處理，會有一個訪案描述元變成作"
228	"用中。依據您的工具結構是否特別，您可以整理讓視窗"
229	"系統工具組在檔案描述元作用時，呼叫一個回叫作用；"
230	"或是將檔案描述元加入一個 select(3) 呼叫之中，以阻"
231	"擋一些檔案描述元。無論使用哪一種方式，都要呼叫"
232	"tt_message_receive() 為包含送入的訊息獲取一個控點。"
233	"您可以使用 tt_message_*() 呼叫來檢查訊息屬性，以決"
234	"定要採取什麼行動。您可以利用比對控點的方式、以"
235	"tt_message_user_set() 呼叫放入訊息中對您的應用程式"
236	"有意義的資訊的方式、或以 tt_message_callback_add 與"
237	"tt_pattern_callback_add 呼叫放入訊息或自串特定的回叫"
238	"等方式，找出您傳送給訊息的回答。"
239	""
240	""
241	"訊息"
242	"--------"
243	"要送出訊息，首先請配置一則新訊息，填入適當的資訊，然後"
244	"將它送出。所有的回答都會出現在同一則訊息中。訊息製作完"
245	"成之後，請釋放一些儲存體供此訊息使用。(對於會傳回一個值"
246	"的要求來說，這個動作請在必要的傳回值複製出去之後進行，"
247	"若只是通知作用，這個動作請在送出後進行。)"
248	""
249	"要配置新訊息，請使用 tt_message_create()。它會傳回一個 "
250	"\"控點\" 或 \"隱藏式的指標\" 給訊息；請將這個控點用於接"
251	"續的呼叫中，以參照此則訊息。"
252	""
253	"要填入訊息資訊，請使用 tt_message_*_set() 呼叫；"
254	"訊息的每個屬性都會有這些項目之一。"
255	""
256	"您必須設定 Class、Address、Op 及 Args。"
257	""
258	"利用 tt_message_send() 送出訊息。"
259	"字串"
260	"--------"
261	"由於訊息並非由送出的處理明確、直接地引導到某個特定的"
262	"收受者，因此我們使用 \"字串比對\" 的方法來決定收受者。"
263	"工具註冊了訊息所登記權益的描述，ToolTalk 使用這些描述"
264	"來推論訊息的途程。其中會保留各別組的字串，以描述工具"
265	"想處理的訊息，以及想觀察的訊息。想接收訊息的工具宣告"
266	"其權益登記的時機，可能是執行時動態宣告，或在安裝時靜"
267	"態宣告。動態註冊包含一組字串，所有訊息都須和這些字串"
268	"比對。如果有訊息與字串相符，註冊此字串的工具即可合法"
269	"接收此訊息。"
270	""
271	""
272	""
273	"在透過 ToolTalk 接收程序訊息之前，一個處理必須向訊息"
274	"傳遞器註冊。透過註冊的過程，處理提供字串給 ToolTalk；"
275	"之後 ToolTalk 再將與這些字串相符的訊息傳遞給處理。這些"
276	"字串可以利用兩種方式建立："
277	""
278	"靜態。透過一個 ptype。一個處理可以向訊息傳遞者宣告"
279	"其 ptype；接下來 ToolTalk 即可從 ptype 中的每個類別記號"
280	"中產生字串。這些產生的字串可利用加入與離開階段作業"
281	"的方式修改，就像在物件導向訊息傳遞時一樣。"
282	""
283	"動態。一個處理可以在 \"執行中\" 建立字串並向"
284	"ToolTalk 註冊。這個機能的典型用法是作為一個"
285	"訊息登錄工具，它只觀察經過的所有訊息，將其"
286	"顯示在一個視窗中；這種工具在訊息協定除錯時"
287	"相當有用。"
288	""
289	"這個應程式只使用動態字串。"
290	""
291	"要為一個字串註冊，首先要配置一個新字串，填入適當的資訊，"
292	"然後再註冊。當您製作好字串之後 (只能在您對於符合此字串的，"
293	"訊息不再感到興趣之後)，請釋放儲存體供字串使用。"
294	""
295	""
296	"要配置新字串，請使用 tt_pattern_create()。它會傳回一個 "
297	"\"控點\" 或 \"隱藏式的指標\" 給字串；請將這個控點用於接"
298	"續的呼叫中，以參照這個字串。"
299	""
300	"要填入字串資訊，請使用 tt_pattern_*_add() 呼叫；"
301	"字串的每個屬性都會有這些項目之一。字串中的每"
302	"一個屬性，您都可以提供多個值，如果字串中的值"
303	"與訊息中的值相符即可。"
304	""
305	""
306	"這個應用程式使用了非互斥的設定值與以逗號分隔的值"
307	"作為多重屬性。"
308	""
309	"要在不考慮特定屬性的值的情況下比對訊息，"
310	"只要在字串中不要加入屬性即可。"
311	""
312	"如果沒有指定字串屬性，ToolTalk 服務會計算訊息屬性的數目，"
313	"作為符合的數目。您指定的字串屬性越少，可以收到的訊息越"
314	"多。"
315	""
316	"如果一個字串屬性指定了多個值，其中一個必須符合訊息屬性"
317	"的值。如果沒有值符合，ToolTalk 就不會將您的應用程式視為"
318	"接收者。"
319	""
320	"屬性的「種類」與「範圍」一定要填入。"
321	""
322	"字串完成之後，請使用 tt_pattern_register() 替這個字串註"
323	"冊，然後選擇「應用」按鈕，依需要加入階段作業中。"
324	""
325	""
326	"由於加入檔案與階段作業的主要效果，是更新目前註冊"
327	"的字串，因此在加入階段作業之後所註冊的字串便不會"
328	"被更新。您最好在加入之前替所有的字串註冊，或在註"
329	"冊新字串之後，重新執行加入的動作。透過加入 ptype，"
330	"這個動作即可應用到明確地註冊的字串。當您利用訊息"
331	"視窗加入訊息時，連接此按鈕的功能表就會變大。選擇"
332	"一個訊息之後，即可將它送出。"
333	"位址："
334	"由於工具的類型很多，不同的使用者又會在不同的時間內"
335	"使用不同組的工具，因此有時訊息寄件人無法明確地判斷"
336	"某個訊息的收受者究竟是誰。因此，相反地，寄件人會提"
337	"供一個操作名稱，指定這個訊息的意義，也可以提供這個"
338	"訊息將被導引到哪一個物件，或提供物件類型 (otype)。"
339	""
340	""
341	"請在物件導向的訊息中使用物件或 otype。如果位址是一個"
342	"處理器，則請指定處理器。"
343	""
344	"        TT_PROCEDURE：所提供的 Op 與 Args。"
345	""
346	"        TT_OBJECT：   所提供的 Object, Op, 與 Args。"
347	""
348	"        TT_HANDLER：  所提供的 Handler, Op, 與 Args。"
349	""
350	"        TT_OTYPE：    所提供的 Otype, Op, 與 Args。"
351	"處理器："
352	"如果您知道處理器確實的 procid，就可以直接對它發送訊息。"
353	"一般的情況是，一個處理發出一個一般性的要求，然後從回"
354	"覆中擇取 Handler 屬性，再引導進一步的訊息到同一個處理"
355	"器；如此即可透過經過的廣播訊息，將兩個處理即集合起來，"
356	"然後一起到達一個對話。"
357	""
358	"Handler_Ptype："
359	"如果您知道將處理這個訊息的處理的 ptype，請填入。只要"
360	"查看 ptype 定義，即可找出協定的細節。"
361	""
362	"物件："
363	"填入這個訊息將被送到的物件之 objid。"
364	"OType："
365	"物件的類型。"
366	"Op："
367	"填入可說明產生的通知或要求的操作。請查看目標物件"
368	"的 otype 定義，即可得知操作名稱。"
369	""
370	"操作號碼："
371	"操作號碼。這可用來分辨過載的操作 (名稱相同但引數類"
372	"型不同的操作)，並簡化客戶機的 \"內部\" 分派 (為給定的"
373	"訊息調用適當的程序。"
374	""
375	"範圍："
376	"如果需要的是來自同一個階段的其他處理的訊息，請使用"
377	"範圍階段作業；如果需要的是關於某個檔案的檔案訊息，"
378	"則請使用範圍檔案。"
379	""
380	"      TT_SESSION：          接收來自您的階段作業中的其他處"
381	"                            理的訊息。"
382	""
383	"      TT_FILE：             接收關於加入的檔案的訊息。"
384	""
385	"      TT_BOTH：             接收關於檔案與階段作業的"
386	"                            訊息。"
387	""
388	"      TT_FILE_IN_SESSION：  接收在階段作業中加入的"
389	"                            檔案的訊息。"
390	"階段作業："
391	"對於範圍階段作業，請指定階段作業 (內定值為"
392	"tt_default_session())。"
393	"檔案："
394	"對於檔案範圍，請指定檔案名稱。"
395	"種類："
396	"使用種類觀察您是否想查看資訊；使用種類控點則可自願"
397	"成為訊息的唯一處理器。"
398	""
399	"	TT_OBSERVE：觀察處理剛剛獲得自身訊息的副本。"
400	"	            任何數目的處理都可以觀察一個訊息。即使某"
401	"		    個訊息是一個要求，觀察者也無法將值傳回給"
402	"		    寄件人。一般說來，觀察者無法將值傳回給寄"
403	"	            件人。通長觀察者所採取的動作只會影響到底"
404	"		    層工具資料的交談式顯式。"
405	""
406	"	TT_HANDLE：處理實際依據該訊息執行某個動作的"
407	"			處理。只有一個處理可以處理所有給定的訊"
408	"			息。如果訊息是一個要求，處理程序就是傳"
409	"			回值的程序。一般說來，處理器所採取的動"
410	"			作，會影響工具資料的持續儲存表現。"
411	""
412	"類別："
413	"類別要求使用於以下情況：用在可傳回值的訊息；用在您"
414	"希望有回饋告知您訊息已被處理或已佇列時；或是當一個"
415	"處理開始要處理這個要求時。對於剛通知其他處理有事件"
416	"發生的訊息，請使用類別通知。"
417	""
418	"	TT_NOTICE：所謂「通告」是通知其他工具有事件發生"
419	"		   的訊息。送出通知的工具不期望有回覆；寄件人"
420	"		   只希望告知其他工具發生了什麼事。"
421	""
422	""
423	"	TT_REQUEST：所謂「要求」是請求其他工具執行"
424	"                   某個動作的訊息。通常 (但是並非絕對)  提"
425	"		    出要求的工具會期待收到傳回值。這個值"
426	"		    即為對此要求的答覆。即使不傳回任何值，"
427	"		    處理這個要求的工具也會送出答覆，告知"
428	"		    成功或失敗。"
429	"處分："
430	"指定如果訊息無法被任何執行中的程序處理，應採取何種行"
431	"動。如果這個訊息應該佇列等待，一直到 Handler_Ptype 的處"
432	"理註冊之後，則決定佇列。如果某個 Handler_Ptype 的處理必"
433	"須啟動，則決定啟動。"
434	""
435	"	TT_QUEUE：將訊息佇列，直到適當 ptype 的處理收到這個"
436	"		  訊息為止。"
437	""
438	"	TT_START：如果沒有處理正在執行，則嘗試啟動一個有適"
439	"		  當 ptype 的處理。"
440	""
441	"注意，Tt_disposition 的值可以相加，因此 TT_QUEUE+TT_START"
442	"就表示兩者都要將訊息佇列，並嘗試啟動一個處理。如果"
443	"啟動可能失敗 (或由使用者否決)，這個功能就可能用到，"
444	"讓合法的處理一啟動之後，訊息立即可以被處理。"
445	""
446	"情況："
447	"一個訊息的狀態屬性的值。可能的值及其代表意義如下："
448	""
449	""
450	"	TT_CREATED： 建立好但未送出的訊息。只有訊息的"
451	"	             寄件人可以看到這種狀態的訊息。"
452	""
453	"	TT_SENT：    已送出但尚未被處理的訊息。"
454	""
455	"	TT_HANDLED： 訊息已被處理，且傳回值是有效的。"
456	""
457	"	TT_FAILED：  訊息無法傳遞到處理器。"
458	""
459	"	TT_QUEUED：  訊息被要求晚一點再傳出。"
460	""
461	"	TT_STARTED:  嘗試啟動一個處理，以便處理訊息。"
462	""
463	"	TT_REJECTED：訊息被一個可能的處理器拒絕。"
464	"       	     這個狀態只要發出拒絕的處理可以看到；"
465	"		     ToolTalk 會在傳遞這個訊息到其他可能的"
466	"		     處理器之前，將狀態改回 TT_SENT。"
467	"狀態："
468	"唯一的數字，指出回覆者所傳回的訊息結果。這個數字"
469	"必須大於 TT_ERR_LAST (2047)。"
470	"狀態字串："
471	"訊息狀態的文字描述。"
472	"寄件人："
473	"指出送出這個訊息的處理。"
474	"寄件人 ptype："
475	"送出這個訊息的處理的 ptype。"
476	"Uid："
477	"送出這個訊息的處理有效的使用者識別字。"
478	"Gid："
479	"送出這個訊息的處理有效的群組識別字。"
480	"模態："
481	"指定訊息引數的模態。可能的值及其意義如下："
482	""
483	""
484	"	TT_IN：   這個引數是由寄件人所寫，由處理器及任何觀察"
485	"		  者所讀取。"
486	""
487	"	TT_OUT：  這個引數是由寄件人所寫，由處理器及任何回覆"
488	"		  觀察者所讀取。"
489	""
490	"	TT_INOUT：這個引數是由寄件人及處理器及任何觀察者所"
491	"		  寫入及讀取。"
492	"類型："
493	"指出類型的字串。一般的值是 \"string\" 與 \"int\"，"
494	"雖然發展人員可以自行建立。"
495	"值："
496	"從屬該類型的值的實際資料。當您按了「應用」"
497	"按鈕之後，收到的每個訊息，就會顯示指定設"
498	"定的值。按了按鈕之後，顯示的值會重設為前"
499	"次應用時的情況或是起始值，看哪一個時間較"
500	"近。"
501	"編輯接收的內文："
502	"增加、刪除或變更您想接收的內文。"
503	"字串比對程式"
504	"---------------"
505	"由於訊息並非由送出的處理明確、直接地引導到某個特定的"
506	"接收者，因此我們使用 \"字串比對\" 的方法來決定接收者。"
507	"工具註冊了訊息所登記權益的描述，ToolTalk 使用這些描述"
508	"來推論訊息的途程。其中會保留各別組的字串，以描述工具"
509	"想處理的訊息，以及想觀察的訊息。想接收訊息的工具宣告"
510	"其權益登記的時機，可能是執行時動態宣告，或在安裝時靜"
511	"態宣告。動態註冊包含一組字串，所有訊息都須和這些字串"
512	"比對。如果有訊息與字串相符，註冊此字串的工具即可合法"
513	"接收此訊息。"
514	""
515	""
516	""
517	""
518	"在透過 ToolTalk 接收程序訊息之前，一個處理必須向訊息"
519	"傳遞器註冊。透過註冊的過程，處理提供字串給 ToolTalk；"
520	"之後 ToolTalk 再將與這些字串相符的訊息傳遞給處理。這些"
521	"字串可以利用兩種方式建立："
522	""
523	"靜態。透過一個 ptype。一個處理可以向 [訊息傳遞者] 宣告"
524	"其 ptype；接下來 ToolTalk 即可從 ptype 中的每個類別記號"
525	"中產生字串。這些產生的字串可利用加入與離開階段作業"
526	"的方式修改，就像在物件導向訊息傳遞時一樣。"
527	""
528	"動態。一個處理可以在 \"執行中\" 建立字串並向"
529	"ToolTalk 註冊。這個機能的典型用法是作為一個"
530	"訊息登錄工具，它只觀察經過的所有訊息，將其"
531	"顯示在一個視窗中；這種工具在訊息協定除錯時"
532	"相當有用。"
533	""
534	"這個應程式只使用動態字串。"
535	""
536	"要為一個字串註冊，首先要配置一個新字串，填入適當的資訊，"
537	"然後再註冊。當您製作好字串之後 (只能在您對於符合此字串的，"
538	"訊息不再感到興趣之後)，請釋放儲存體供字串使用。"
539	""
540	""
541	"要配置新字串，請使用 tt_pattern_create()。它會傳回一個 "
542	"\"控點\" 或 \"隱藏式的指標\" 給字串；請將這個控點用於接"
543	"續的呼叫中，以參照這個字串。"
544	""
545	"要填入字串資訊，請使用 tt_pattern_*_add() 呼叫；"
546	"字串的每個屬性都會有這些項目之一。字串中的每"
547	"一個屬性，您都可以提供多個值，如果字串中的值"
548	"與訊息中的值相符即可。"
549	""
550	""
551	"這個應用程式使用了非互斥的設定值與以逗號分隔的值"
552	"作為多重屬性。"
553	""
554	"要在不考慮特定屬性的值的情況下比對訊息，"
555	"只要在字串中不要加入屬性即可。"
556	""
557	"如果沒有指定字串屬性，ToolTalk 服務會計算訊息屬性的數目，"
558	"作為符合的數目。您指定的字串屬性越少，可以收到的訊息越"
559	"多。"
560	""
561	"如果一個字串屬性指定了多個值，其中一個必須符合訊息屬性"
562	"的值。如果沒有值符合，ToolTalk 就不會將您的應用程式視為"
563	"接收者。"
564	""
565	"屬性的「種類」與「範圍」一定要填入。"
566	""
567	"字串完成之後，請使用 tt_pattern_register() 替這個字串註"
568	"冊，然後選擇「應用」按鈕，依需要加入階段作業中。"
569	""
570	""
571	"由於加入檔案與階段作業的主要效果，是更新目前註冊"
572	"的字串，因此在加入階段作業之後所註冊的字串便不會"
573	"被更新。您最好在加入之前替所有的字串註冊，或在註"
574	"冊新字串之後，重新執行加入的動作。透過加入 ptype，"
575	"這個動作即可應用到明確地註冊的字串。當您利用訊息"
576	"視窗加入訊息時，連接此按鈕的功能表就會變大。選擇"
577	"一個訊息之後，即可將它送出。"
578	"位址："
579	"由於工具的類型很多，不同的使用者又會在不同的時間內"
580	"使用不同組的工具，因此有時訊息寄件人無法明確地判斷"
581	"某個訊息的收受者究竟是誰。因此，相反地，寄件人會提"
582	"供一個操作名稱，指定這個訊息的意義，也可以提供這個"
583	"訊息將被導引到哪一個物件，或提供物件類型 (otype)。"
584	""
585	"請在物件導向的訊息中使用物件或 otype。如果位址是一個"
586	"處理器，則請指定處理器。"
587	""
588	"	  TT_PROCEDURE：提供了 Op 與 Args。"
589	""
590	"	  TT_OBJECT：   提供了 Object, Op, 與 Args。"
591	""
592	"	  TT_HANDLER：  提供了 Handler, Op, 與 Args。"
593	""
594	"	  TT_OTYPE：	提供了 Otype, Op, 與 Args。"
595	"物件："
596	"填入這個訊息將被送到的物件之 objid。"
597	"OType："
598	"物件的類型。"
599	"Op："
600	"填入可說明產生的通知或要求的操作。請查看目標物件"
601	"的 otype 定義，即可得知操作名稱。"
602	""
603	"範圍："
604	"如果需要的是來自同一個階段的其他處理的訊息，請使用"
605	"範圍階段作業；如果需要的是關於某個檔案的檔案訊息，"
606	"則請使用範圍檔案。"
607	""
608	"	TT_SESSION：	   接收來自您的階段作業中的其他處"
609	"			   理的訊息。"
610	""
611	"	TT_FILE：	   接收關於加入的檔案的訊息。"
612	""
613	"	TT_BOTH：	   接收關於檔案與階段作業的訊息。"
614	""
615	"	TT_FILE_IN_SESSION： 接收在階段作業中加入"
616	"		             檔案的訊息。"
617	"檔案："
618	"對於檔案範圍，請指定檔案名稱。"
619	"階段作業："
620	"對於範圍階段作業，請指定階段作業 (內定值為"
621	"tt_default_session())。"
622	"種類："
623	"使用種類觀察您是否想查看資訊；使用種類控點則可自願"
624	"成為訊息的唯一處理器。"
625	""
626	"	TT_OBSERVE：觀察處理剛剛獲得自身訊息的副本。"
627	"		    任何數目的處理都可以觀察一個訊息。即使某"
628	"		    個訊息是一個要求，觀察者也無法將值傳回給"
629	"		    寄件人。一般說來，觀察者無法將值傳回給寄"
630	"		    件人。通常觀察者所採取的動作只會影響到底"
631	"		    層工具資料的交談式顯式。"
632	""
633	"	TT_HANDLE：處理實際依據該訊息執行某個動作的"
634	"		   處理。只有一個處理可以處理所有給定的訊"
635	"		   息。如果訊息是一個要求，處理程序就是傳"
636	"		   回值的程序。一般說來，處理器所採取的動"
637	"		   作，會影響工具資料的持續儲存表現。"
638	""
639	"類別："
640	"類別要求使用於以下情況：用在可傳回值的訊息；用在您"
641	"希望有回饋告知您訊息已被處理或已佇列時；或是當一個"
642	"處理開始要處理這個要求時。對於剛通知其他處理有事件"
643	"發生的訊息，請使用類別通知。"
644	""
645	"	TT_NOTICE：所謂「通告」是通知其他工具有事件發生"
646	"		   的訊息。送出通知的工具不期望有回覆；寄件人"
647	"		   只希望告知其他工具發生了什麼事。"
648	""
649	""
650	"	TT_REQUEST：所謂「要求」是請求其他工具執行"
651	"		    某個動作的訊息。通常 (但是並非絕對)  提"
652	"		    提出要求的工具會期待收到傳回值。這個值"
653	"		    即為對此要求的答覆。即使不傳回任何值，"
654	"		    處理這個要求的工具也會送出答覆，告知"
655	"		    成功或失敗。"
656	"情況："
657	"一個訊息的狀態屬性的值。可能的值及其代表意義如下："
658	""
659	""
660	"	TT_CREATED： 建立好但未送出的訊息。只有訊息的"
661	"		     寄件人可以看到這種狀態的訊息。"
662	""
663	"	TT_SENT：    已送出但尚未被處理的訊息。"
664	""
665	"	TT_HANDLED： 訊息已被處理，且傳回值是有效的。"
666	""
667	"	TT_FAILED：  訊息無法傳遞到處理器。"
668	""
669	"	TT_QUEUED：  訊息被要求晚一點再傳出。"
670	""
671	"	TT_STARTED:  嘗試啟動一個處理，以便處理訊息。"
672	""
673	"	TT_REJECTED：訊息被一個可能的處理器拒絕。"
674	"		     這個狀態只要發出拒絕的處理可以看到；"
675	"		     ToolTalk 會在傳遞這個訊息到其他可能的"
676	"		     處理器之前，將狀態改回 TT_SENT。"
677	"處分："
678	"指定如果訊息無法被任何執行中的程序處理，應採取何種行"
679	"動。如果這個訊息應該佇列等待，一直到 Handler_Ptype 的處"
680	"理註冊之後，則決定佇列。如果某個 Handler_Ptype 的處理必"
681	"須啟動，則決定啟動。"
682	""
683	"	TT_QUEUE：將訊息佇列，直到適當 ptype 的處理收到這個"
684	"		  訊息為止。"
685	""
686	"	TT_START：如果沒有處理正在執行，則嘗試啟動一個有適"
687	"		  當 ptype 的處理。"
688	""
689	"注意，Tt_disposition 的值可以相加，因此 TT_QUEUE+TT_START"
690	"就表示兩者都要將訊息佇列，並嘗試啟動一個處理。如果"
691	"啟動可能失敗 (或由使用者否決)，這個功能就可能用到，"
692	"讓合法的處理一啟動之後，訊息立即可以被處理。"
693	""
694	"寄件人："
695	"指出送出這個訊息的處理。"
696	"寄件人 ptype："
697	"送出這個訊息的處理的 ptype。"
698	"Args："
699	"填入此項操作特定的引數。請使用 tt_message_arg_add --"
700	"加入各個引數。每個引數都要指定以下項目：模態 (in、out"
701	"或 inout)、類型，如果模態不是 in 或 inout，則須指定數值。"
702	"模態："
703	"指定訊息引數的模態。可能的值及其意義如下："
704	""
705	""
706	"	TT_IN：   這個引數是由寄件人所寫，由處理器及任何觀察"
707	"		  者所讀取。"
708	""
709	"	TT_OUT：  這個引數是由寄件人所寫，由處理器及任何回覆"
710	"		  觀察者所讀取。"
711	""
712	"	TT_INOUT：這個引數是由寄件人及處理器及任何觀察者所"
713	"		  寫入及讀取。"
714	"類型："
715	"指出類型的字串。一般的值是 \"string\" 與 \"int\"，"
716	"雖然發展人員可以自行建立。"
717	"值："
718	"從屬該類型的值的實際資料。"
719	"增加按鈕："
720	"在模態、類型和值中增加一個引數。"
721	"刪除按鈕："
722	"刪除選取的引數。"
723	"變更按鈕："
724	"將選取的引數改為目前模態、類型與值的"
725	"現行值。"
726	"應用按鈕："
727	"註冊以接收符合此字串的訊息。"
728	"名稱："
729	"這個上下文的名稱"
730	"值："
731	"此種類型適用的值，"
732	""
733	"亦即 int 類型為 55，char 類型為 \"fred\"，bytes 類型為"
734	"^V^L^X。"
735	"增加上下文："
736	"在上下文列示中，加入名稱與值兩個欄位現行"
737	"的值。"
738	"刪除上下文："
739	"從上下文列示中刪除選取的項目。"
740	"變更上下文："
741	"將選取的項目改為名稱和值兩個欄位中的資料。"
742	"編輯送出上下文："
743	"是一個即現視窗，供您編輯您想傳送的上下文列示。"
744	"訊息"
745	"-------"
746	"要送出訊息，首先請配置一則新訊息，填入適當的資訊，然後"
747	"將它送出。所有的回答都會出現在同一則訊息中。訊息製作完"
748	"成之後，請釋放一些儲存體供此訊息使用。(對於會傳回一個值"
749	"的要求來說，這個動作請在必要的傳回值複製出去之後進行，"
750	"若只是通知作用，這個動作請在送出後進行。)"
751	""
752	"要配置新訊息，請使用 tt_message_create()。它會傳回一個 "
753	"\"控點\" 或 \"隱藏式的指標\" 給訊息；請將這個控點用於接"
754	"續的呼叫中，以參照此則訊息。"
755	""
756	"要填入訊息資訊，請使用 tt_message_*_set() 呼叫；"
757	"訊息的每個屬性都會有這些項目之一。"
758	""
759	"您必須設定 Class、Address、Op 及 Args。"
760	""
761	"利用 tt_message_send() 送出訊息。"
762	"位址："
763	"由於工具的類型很多，不同的使用者又會在不同的時間內"
764	"使用不同組的工具，因此有時訊息寄件人無法明確地判斷"
765	"某個訊息的收受者究竟是誰。因此，相反地，寄件人會提"
766	"供一個操作名稱，指定這個訊息的意義，也可以提供這個"
767	"訊息將被導引到哪一個物件，或提供物件類型 (otype)。"
768	""
769	""
770	"請在物件導向的訊息中使用物件或 otype。如果位址是一個"
771	"處理器，則請指定處理器。"
772	""
773	"	  TT_PROCEDURE：所提供的 Op 與 Args。"
774	""
775	"	  TT_OBJECT：   所提供的 Object, Op, 與 Args。"
776	""
777	"	  TT_HANDLER：  所提供的 Handler, Op, 與 Args。"
778	""
779	"	  TT_OTYPE：	所提供的 Otype, Op, 與 Args。"
780	"處理器："
781	"如果您知道處理器確實的 procid，就可以直接對它發送訊息。"
782	"一般的情況是，一個處理發出一個一般性的要求，然後從回"
783	"覆中擇取 Handler 屬性，再引導進一步的訊息到同一個處理"
784	"器；如此即可透過經過的廣播訊息，將兩個處理即集合起來，"
785	"然後一起到達一個對話。"
786	""
787	"Handler_Ptype："
788	"如果您知道將處理這個訊息的處理的 ptype，請填入。只要"
789	"查看 ptype 定義，即可找出協定的細節。"
790	""
791	"物件："
792	"填入這個訊息將被送到的物件之 objid。"
793	"OType："
794	"物件的類型。"
795	"Op："
796	"填入可說明產生的通知或要求的操作。請查看目標物件"
797	"的 otype 定義，即可得知操作名稱。"
798	""
799	"範圍："
800	"如果需要的是來自同一個階段的其他處理的訊息，請使用"
801	"範圍階段作業；如果需要的是關於某個檔案的檔案訊息，"
802	"則請使用範圍檔案。"
803	""
804	"	TT_SESSION：	   接收來自您的階段作業中的其他處"
805	"			   理的訊息。"
806	""
807	"	TT_FILE：	   接收關於加入的檔案的訊息。"
808	""
809	"	TT_BOTH：	   接收關於檔案與階段作業的訊息。"
810	""
811	"	TT_FILE_IN_SESSION： 接收在階段作業中加入"
812	"			     檔案的訊息。"
813	"階段作業："
814	"對於範圍階段作業，請指定階段作業 (內定值為"
815	"tt_default_session())。"
816	"檔案："
817	"對於檔案範圍，請指定檔案名稱。"
818	"類別："
819	"類別要求使用於以下情況：用在可傳回值的訊息；用在您"
820	"希望有回饋告知您訊息已被處理或已佇列時；或是當一個"
821	"處理開始要處理這個要求時。對於剛通知其他處理有事件"
822	"發生的訊息，請使用類別通知。"
823	""
824	"	TT_NOTICE：所謂「通告」是通知其他工具有事件發生"
825	"		   的訊息。送出通知的工具不期望有回覆；寄件人"
826	"		   只希望告知其他工具發生了什麼事。"
827	""
828	""
829	"	TT_REQUEST：所謂「要求」是請求其他工具執行"
830	"		    某個動作的訊息。通常 (但是並非絕對)  提"
831	"		    出要求的工具會期待收到傳回值。這個值"
832	"		    即為對此要求的答覆。即使不傳回任何值，"
833	"		    處理這個要求的工具也會送出答覆，告知"
834	"		    成功或失敗。"
835	"處分："
836	"指定如果訊息無法被任何執行中的程序處理，應採取何種行"
837	"動。如果這個訊息應該佇列等待，一直到 Handler_Ptype 的處"
838	"理註冊之後，則決定佇列。如果某個 Handler_Ptype 的處理必"
839	"須啟動，則決定啟動。"
840	""
841	"	TT_QUEUE：將訊息佇列，直到適當 ptype 的處理收到這個"
842	"		  訊息為止。"
843	""
844	"	TT_START：如果沒有處理正在執行，則嘗試啟動一個有適"
845	"		  當 ptype 的處理。"
846	""
847	"注意，Tt_disposition 的值可以相加，因此 TT_QUEUE+TT_START"
848	"就表示兩者都要將訊息佇列，並嘗試啟動一個處理。如果"
849	"啟動可能失敗 (或由使用者否決)，這個功能就可能用到，"
850	"讓合法的處理一啟動之後，訊息立即可以被處理。"
851	""
852	"Sender_Ptype："
853	"送出這個訊息的處理的 ptype。"
854	"狀態："
855	"唯一的數字，指出回覆者所傳回的訊息結果。這個數字"
856	"必須大於 TT_ERR_LAST (2047)。"
857	"狀態字串："
858	"訊息狀態的文字描述。"
859	"Args："
860	"填入此項操作特定的引數。請使用 tt_message_arg_add 一一"
861	"加入各個引數。每個引數都要指定以下項目：模態 (in、out"
862	"或 inout)、類型，如果模態不是 in 或 inout，則須指定數值。"
863	""
864	"模態："
865	"指定訊息引數的模態。可能的值及其意義如下："
866	""
867	""
868	"	TT_IN：   這個引數是由寄件人所寫，由處理器及任何觀察"
869	"		  者所讀取。"
870	""
871	"	TT_OUT：  這個引數是由寄件人所寫，由處理器及任何回覆"
872	"		  觀察者所讀取。"
873	""
874	"	TT_INOUT：這個引數是由寄件人及處理器及任何觀察者所"
875	"		  寫入及讀取。"
876	"類型："
877	"指出類型的字串。一般的值是 \"string\" 與 \"int\"，"
878	"雖然發展人員可以自行建立。"
879	"值："
880	"從屬該類型的值的實際資料。"
881	"增加按鈕："
882	"在模態、類型和值中增加一個引數。"
883	"刪除按鈕："
884	"刪除選取的引數。"
885	"變更按鈕："
886	"將選取的引數改為目前模態、類型與值的"
887	"現行值。"
888	"送出按鈕："
889	"送出這個訊息。同時也在標準輸出上列出用來建立與發"
890	"送這個訊息的 ToolTalk 呼叫。"
891	"名稱："
892	"這個上下文的名稱"
893	"值："
894	"這個上下文的值，解釋成類型。"
895	"增加："
896	"在文字欄位中加入值，作為新的上下文。"
897	"刪除："
898	"刪除目前選取的上下文。"
899	"變更："
900	"變更選取的上下文，以反映出目前文字欄位"
901	"的內容。"
902	"無法開啟管道供 sieve 輸出之用。\n"
903	"Tts_string_list：產生呼叫訊息 - 忽略 \n"
$set 11
2	"TT_OK\t要求成功。"
3	"TT_WRN_NOTFOUND\t此物件未被除去，因為無法找到。"
4	"TT_WRN_STALE_OBJID\t訊息中的物件屬性已被換新。請更新獲取物件 id 的位置。"
5	"TT_WRN_STOPPED\t查詢被過濾器程序中止。"
6	"TT_WRN_SAME_OBJID\t被移動的物件保有同樣的 objid。"
7	"TT_WRN_START_MESSAGE\t此訊息將啟動此程序。即使它只是一個通告，仍舊需要回覆。"
8	"TT_WRN_APPFIRST\t這個碼必須取消使用。"
9	"TT_WRN_LAST\t這個碼必須取消使用。"
10	"TT_ERR_CLASS\t傳遞的 Tt_class 值是無效的。"
11	"TT_ERR_DBAVAIL\t無法獲得必要的資料庫。這可能只是暫時性的狀態，等一下再試也許就會成功。"
12	"TT_ERR_DBEXIST\t必要的資料庫不存在。必須先建立資料庫後，這個動作才能執行。"
13	"TT_ERR_FILE\t找不到檔案物件。"
14	"TT_ERR_MODE\tTt_mode 值是無效的。"
15	"TT_ERR_ACCESS\t您嘗試要存取某個 ToolTalk 物件的方式，是保護系統所禁止的。"
16	"TT_ERR_NOMP\t沒有 ttsession 處理正在執行，也許是因為尚未呼叫。如果這個碼是從 tt_open() 傳回，表示 ttsession 無法啟動，通常代表此系統沒有安裝 ToolTalk。"
17	"TT_ERR_NOTHANDLER\t只有訊息的處理器可以執行這個動作。"
18	"TT_ERR_NUM\t傳遞的整數是無效的。"
19	"TT_ERR_OBJID\t傳遞的 object id 沒有參照到任何現存的物件規格。"
20	"TT_ERR_OP\t傳遞的操作名稱語法有誤。"
21	"TT_ERR_OTYPE\t傳遞的物件類型並非已安裝的物件類型。"
22	"TT_ERR_ADDRESS\t傳遞的 Tt_address 值是無效的。"
23	"TT_ERR_PATH\t傳遞的檔案路徑中的某個目錄不存在或無法讀取。"
24	"TT_ERR_POINTER\t傳遞的隱藏式指標 (控點) 並非表示一個適當類型的物件。"
25	"TT_ERR_PROCID\t傳遞的處理 id 是無效的。"
26	"TT_ERR_PROPLEN\t傳遞的特性值太長。"
27	"TT_ERR_PROPNAME\t傳遞的特性名稱語法有誤。"
28	"TT_ERR_PTYPE\t傳遞的處理類型並非已安裝的處理類型名稱。"
29	"TT_ERR_DISPOSITION\t傳遞的 Tt_disposition 值是無效的。"
30	"TT_ERR_SCOPE\t傳遞的 Tt_scope 值是無效的。"
31	"TT_ERR_SESSION\t傳遞的 session id 並非作用中階段作業的名稱。"
32	"TT_ERR_VTYPE\t傳遞的值類型名稱是無效的。"
33	"TT_ERR_NO_VALUE\t具有指定的名稱與號碼的特性值不存在。"
34	"TT_ERR_INTERNAL\t內部錯誤 (bug)"
35	"TT_ERR_READONLY\t屬性無法變更。"
36	"TT_ERR_NO_MATCH\t這個訊息找不到處理器，因此處分並未佇列或啟動。"
37	"TT_ERR_UNIMP\t此功能並未製作。"
38	"TT_ERR_OVERFLOW\t作用中的訊息太多 (請稍後再試)。"
39	"TT_ERR_PTYPE_START\t發射 ptype 實例的嘗試失敗。"
40	"TT_ERR_CATEGORY\t字串物件尚未設定種類。"
41	"TT_ERR_DBUPDATE\t資料庫不一致：另一個 tt_spec_write 先更新物件。"
42	"TT_ERR_DBFULL\tTooltalk 資料庫已滿。"
43	"TT_ERR_DBCONSIST\t資料庫已損毀，或存取資料不完整 (請執行 ttdbck)。"
44	"TT_ERR_STATE\tTt_message 位於對您嘗試的操作無效的 Tt_state 中。"
45	"TT_ERR_NOMEM\t記憶體已用盡。"
46	"TT_ERR_SLOTNAME\t插槽名稱句法有誤。"
47	"TT_ERR_XDR\t傳遞的 XDR proc. 得值為 zero len，或在呼叫時失敗。"
48	"TT_ERR_NETFILE\t傳遞的 netfilename 句法有誤。"
49	"TT_DESKTOP_UNMODIFIED\t此項操作不能應用於未修改過的實體"
50	"TT_MEDIA_ERR_SIZE\t指定的大小過大或過小"
51	"TT_MEDIA_ERR_FORMAT\t資料未遵從原先宣告的格式"
52	"TT_ERR_APPFIRST\t這個碼應取消使用。"
53	"TT_ERR_LAST\t這個碼應取消使用。"
54	"TT_STATUS_LAST\t這個碼應取消使用。"
55	"不明的 Tt_status 值。"
56	"TT_DESKTOP_EPERM\t不是高階使用者"
57	"TT_DESKTOP_ENOENT\t無此這個檔案或目錄"
58	"TT_DESKTOP_EINTR\t系統呼叫被岔斷"
59	"TT_DESKTOP_EIO\tI/O 錯誤"
60	"TT_DESKTOP_EAGAIN\t已經沒有處理了"
61	"TT_DESKTOP_ENOMEM\t空間不足"
62	"TT_DESKTOP_EACCES\t存取遭拒"
63	"TT_DESKTOP_EFAULT\t位址錯誤"
64	"TT_DESKTOP_EEXIST\t檔案已存在"
65	"TT_DESKTOP_ENODEV\t無此裝置"
66	"TT_DESKTOP_ENOTDIR\t不是一個目錄"
67	"TT_DESKTOP_EISDIR\t是一個目錄"
68	"TT_DESKTOP_EINVAL\t無效的引數"
69	"TT_DESKTOP_ENFILE\t檔案表外溢"
70	"TT_DESKTOP_EMFILE\t開啟太多檔案"
71	"TT_DESKTOP_ETXTBSY\t文字檔案使用中"
72	"TT_DESKTOP_EFBIG\t檔案太大"
73	"TT_DESKTOP_ENOSPC\t裝置中已沒有空間"
74	"TT_DESKTOP_EROFS\t唯讀檔案系統"
75	"TT_DESKTOP_EMLINK\t太多連結"
76	"TT_DESKTOP_EPIPE\t管道中斷"
77	"TT_DESKTOP_ENOMSG\t沒有您需要的類型的訊息"
78	"TT_DESKTOP_EDEADLK\t遇到死結狀況"
79	"TT_DESKTOP_ENODATA\t無法取得資料"
80	"TT_DESKTOP_EPROTO\t協定錯誤"
81	"TT_DESKTOP_ENOTEMPTY\t目錄不是空的"
82	"TT_DESKTOP_ETIMEDOUT\t連接逾時"
83	"TT_DESKTOP_EALREADY\t操作已在進行"
84	"TT_DESKTOP_ECANCELED\t操作已取消"
85	"TT_DESKTOP_ENOTSUP\t不支援此選項"

